---
title: "3A: Polynomial Growth"
params: 
    SHOW_SOLS: FALSE
    TOGGLE: TRUE
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| include: false
source('assets/setup.R')
library(xaringanExtra)
library(tidyverse)
library(patchwork)
xaringanExtra::use_panelset()
source("https://uoepsy.github.io/msmr/functions/code_poly.R")
```


:::lo
This reading:  


:::


We have already seen in the last couple of weeks that we can use MLM to study something 'over the course of X'. In the novel word learning experiment from last week's lab, we investigated the change in the probability of answering correctly over the course of the experimental blocks. 

We've talked about how **"longitudinal"** is the term commonly used to refer to any data in which repeated measurements are taken over a continuous domain. This opens up the potential for observations to be unevenly spaced, or missing at certain points. It also, as will be the focus of this week, opens the door to thinking about how many effects of interest are likely to display **non-linear patterns**. These exercises focus on including higher-order polynomials in the multi-level model to capture non-linearity. 
  
# Linear vs Non-Linear

```{r include=F}
res <- MASS::mcycle %>%
  rename(y=accel,x=times) %>% filter(x>20) %>% lm(y~x,.) %>% broom::tidy() %>% mutate(across(estimate:statistic,~round(.,2)))
```

<div style="display:inline-block;width:45%;margin:5px;vertical-align:middle">
Suppose we had collected the data in Figure \@ref(fig:mcycle), and we wanted to fit a model to predict $y$ based on the values of $x$.  

Let's use our old friend linear regression, $y = \beta_0 + \beta_1(x) + \varepsilon$.  

We'll get out some estimated coefficients, some standard errors, and some p-values:  

- The intercept:  
  $\beta_0$ = `r res[1,2]`, SE = `r res[1,3]`, p < .001  
- The estimated coefficient of x:  
  $\beta_1$ = `r res[2,2]`, SE = `r res[2,3]`, p < .001   

Job done? Clearly not - we need only overlay model upon raw data (Figure \@ref(fig:mcycle3)) to see we are missing some key parts of the pattern.  
</div>
<div style="display:inline-block;width:45%;margin:5px;vertical-align:middle">
```{r mcycle, echo=FALSE, fig.cap = "A clearly non-linear pattern"}
MASS::mcycle %>%
  rename(y=accel,x=times) %>% filter(x>20) %>%
  ggplot(.,aes(x=x,y=y))+
  geom_point(size=2)
```
```{r mcycle3, echo=FALSE, fig.asp=.7,fig.cap="Uh-oh... "}
MASS::mcycle %>%
  rename(y=accel,x=times) %>% filter(x>20) %>% 
  lm(y~x,.) %>%
  sjPlot::plot_model(type="pred", show.data = TRUE) -> p0
p0$x
```

</div>  

:::statbox
**Thoughts about Model + Error**  

All our work here is in aim of making models of the world.  

1. Models are just models. They are simplifications, and so they don't perfectly fit to the observed world (indeed, how well a model fits to the world is often our metric for comparing models).  
2. $y - \widehat{y}$. Our observed data minus our model predicted values (i.e. in linear regression our "residuals") reflect everything that we don't account for in our model
3. In an ideal world, our model accounts for all the systematic relationships, and what is left over (our residuals) is just randomness. If our model is mis-specified, or misses out something systematic, then our residuals will reflect this. 
4. We check for this by examining how much like randomness the residuals appear to be (zero mean, normally distributed, constant variance, i.i.d ("independent and identically distributed") - i.e., what gets referred to as the "assumptions"). 
5. We will **never** know whether our residuals contain only randomness, because we can never observe *everything*. 

<h/>

Let's just do a quick `plot(model)` for some diagnostic plots of my linear model:
```{r echo=FALSE, out.width = "100%"}
par(mfrow=c(2,2))
MASS::mcycle %>%
  rename(y=accel,x=times) %>% filter(x>20) %>%
lm(y~x,.) %>% plot()
par(mfrow=c(1,1))
```

Does it look like the residuals are independently distributed? Not really. 
We need to find some way of incorporating the non-linear relationship between y and x into our model. 

:::


# What is a polynomial?  

:::statbox
Polynomials are mathematical expressions which involve a sum of powers. For instance:

- $y = 4 + x + x^2$ is a second-order polynomial as the highest power of $x$ that appears is $x^2$  
- $y = 9x + 2x^2 + 4x^3$ is a third-order polynomial as the highest power of $x$ that appears is $x^3$  
- $y = x^6$ is a sixth-order polynomial as the highest power of $x$ that appears is $x^6$  

:::

For our purposes, extending our model to include higher-order terms can fit non-linear relationships between two variables. For instance, fitting models with linear and quadratic terms ($y_i$ = $\beta_0 + \beta_1 x_{i} \ + \beta_2 x^2_i + \varepsilon_i$) and extending these to cubic ($y_i$ = $\beta_0 + \beta_1 x_{i} \ + \beta_2 x^2_i + \beta_3 x^3_i + \varepsilon_i$) (or beyond), may aid in modelling nonlinear patterns.

```{r echo=FALSE, out.width = "100%", fig.heigth = 4}
MASS::mcycle %>%
  rename(y=accel,x=times) %>% filter(x>20) %>% 
  lm(y~x+I(x^2),.) %>%
  sjPlot::plot_model(type="pred",show.data=TRUE) -> p

MASS::mcycle %>%
  rename(y=accel,x=times) %>% filter(x>20) %>% 
  lm(y~x+I(x^2)+I(x^3),.) %>% 
  sjPlot::plot_model(type="pred",show.data=TRUE) -> p1

p0$x + labs(title="",subtitle="y ~ x + e") +
p$x + labs(title="",subtitle="y ~ x + x^2 + e") +
p1$x + labs(title="",subtitle="y ~ x + x^2 + x^3 + e") & theme_bw(base_size=12)
```

:::statbox
**What are we interested in here?**  

As the order of polynomials increases, we tend to be less interested in these terms in our model. Linear change is the easiest to think about: are things going up over the course of $x$, or down? (or neither?). Quadratic change is the next most interesting, and it may help to think of this as the "rate of change". For instance, in the plot below, it is the quadratic term which differs between the two groups trajectories. 

```{r echo=FALSE}
x=1:10
tibble(
  y=c(x*3, (x*1.1+(x^2)*.2)),
  xx=rep(x,2),
  g = rep(letters[1:2],each=10)
) %>% ggplot(.,aes(x=xx,y=y,col=g))+geom_line()+
  labs(x="x")
```

`r optbegin("Positive and negative quadratic terms",olabel=FALSE,toggle=params$TOGGLE)`
```{r quadfig, echo=FALSE}
tibble(
  x = -10:10,
  y = x^2,
  y1 = -x^2
) %>% pivot_longer(y:y1) %>%
  mutate(name = ifelse(name=="y","quadratic term is positive \n Y = X^2", "quadratic term is negative \n Y = -X^2")) %>%
  ggplot(.,aes(x=x,y=value,col=name)) +
  geom_line()+
  guides(col=FALSE)+
  facet_wrap(~name, scales="free_y")
```

<!-- `r optbegin("Code to create plot", olabel=FALSE, toggle=params$TOGGLE)` -->
<!-- ```{r eval=FALSE} -->
<!-- tibble( -->
<!--   x = -10:10, -->
<!--   y = x^2, -->
<!--   y1 = -x^2 -->
<!-- ) %>% pivot_longer(y:y1) %>% -->
<!--   mutate(name = ifelse(name=="y","quadratic term is positive \n Y = X^2", "quadratic term is negative \n Y = -X^2")) %>% -->
<!--   ggplot(.,aes(x=x,y=value,col=name)) + -->
<!--   geom_line()+ -->
<!--   guides(col=FALSE)+ -->
<!--   facet_wrap(~name, scales="free_y") -->
<!-- ``` -->
<!-- `r optend()` -->

`r optend()`
:::



## Raw Polynomials

<div style="display:inline-block; width: 60%; vertical-align: top">
There are two types of polynomial we can construct. "Raw" (or "Natural") polynomials are the straightforward ones you might be expecting the table to the right to be filled with.  

These are simply the original values of the x variable to the power of 2, 3 and so on.  
  
We can quickly get these in R using the `poly()` function, with `raw = TRUE`.  

If you want to create "raw" polynomials, make sure to specify `raw = TRUE` or you will not get what you want because the default behaviour is `raw = FALSE`.
</div>
<div style="display:inline-block; width: 30%;">
<center>
```{r echo=FALSE}
MASS::mcycle %>%
    rename(y=accel,x=times) %>% filter(x>20) -> df
cbind(x=1:5,`x^2`=rep("?",5),`x^3`=rep("?",5)) %>% rbind("...") %>% 
    kableExtra::kable() %>%
    kableExtra::kable_styling(full_width = FALSE)
```
</center>
</div>

```{r}
poly(1:10, degree = 3, raw=TRUE)
```


<div style="background-color: #eafaff; border-radius: 5px; padding: 20px 20px 10px 20px; margin-top: 20px; margin-bottom: 20px;">
**Raw polynomials are correlated**  

With raw (or "natural") polynomials, the terms `poly1`, `poly2` and `poly3` are correlated.  
Think think about why this might be - by definition, as $x^1$ increases, so will $x^2$, and so will $x^3$ and so on.  

We can visualise them: 
```{r}
matplot(poly(1:10, 3, raw=T), type="l")
```
And measure the correlation coefficients:
```{r}
cor(poly(1:10, 3, raw=T)) %>% round(2)
```

Why might this be a problem?  
Well, this multicollinearity can lead to estimation problems, and means that our parameter estimates may change considerably depending upon what terms we include in our model, and it becomes more difficult to determine which ones are important, and what the effect sizes are.  
Table \@ref(tab:rawpolytab) below shows the coefficients for models fitted to a randomly generated dataset, with `poly1`, `poly1+poly2`, and `poly1+poly2+poly3` as predictors (where `poly1`-`poly3` are **natural** polynomials). Notice that they change with the addition of each term.
```{r rawpolytab, echo=FALSE}
set.seed(754)
df<-tibble(
    x = 1:10,
    y = x + 
        rnorm(1, mean = 100) * (x) +
        rnorm(1, mean = 0, sd = .01) * (x) ^ 2 +
        rnorm(1, mean = -1) * (x) ^ 3 + 
        rnorm(10)
)
df <- code_poly(df = df, predictor = 'x', poly.order = 3, orthogonal = FALSE, draw.poly = FALSE)
full_join(
    broom::tidy(lm(y~poly1, df))[,1:2] %>% 
        #mutate(estimate = paste(round(estimate,2), c("*","**"))) %>% 
        rename(`y~poly1` = estimate),
    broom::tidy(lm(y~poly1+poly2, df))[,1:2] %>% 
        #mutate(estimate = paste(round(estimate,2), c("*","***","***"))) %>% 
        rename(`y~poly1+poly2` = estimate)
) %>% full_join(.,
                broom::tidy(lm(y~poly1+poly2+poly3, df))[,1:2] %>% 
                    #mutate(estimate = paste(round(estimate,2), c("","***","","***"))) %>% 
                    rename(`y~poly1+poly2+poly3` = estimate)
) %>% mutate_if(is.numeric,~round(.,2)) %>% 
    mutate_all(~ifelse(is.na(.), "-", .)) %>% 
    kableExtra::kbl(caption = "Incremental addition of raw polynomial terms") %>%
    kableExtra::kable_styling(full_width = FALSE)
```

</div>

## Orthogonal Polynomials  

"Orthogonal" polynomials are uncorrelated (hence the name). 
We can get these for $x = 1,2,...,9,10$ using the following code:
```{r}
poly(1:10, degree = 3, raw = FALSE)
```
Notice that the first order term has been scaled, so instead of the values 1 to 10, we have values ranging from -0.5 to +0.5, centered on 0. 

```{r}
colMeans(poly(1:10, degree = 3, raw = FALSE)) %>%
    round(2)
```

As you can see from the output above, which computes the mean of each column, each predictor has mean 0, so they are mean-centred. __This is a key fact and will affect the interpretation of our predictors later on__.

Think about what this means for $x^2$. It will be uncorrelated with $x$ (because $-0.5^2 = 0.5^2$)!  
```{r}
matplot(poly(1:10, 3, raw=F), type="l")
```
The correlations are zero!
```{r}
cor(poly(1:10, 3, raw=F)) %>% round(2)
```

We can then fit the same models `y~poly1`, `y~poly1+poly2`, and `y~poly1+poly2+poly3` as predictors (where `poly1`-`poly3` are now **orthogonal** polynomials), and see that estimated coefficients do not change between models: 
```{r orthpolytab, echo=FALSE}
df <- code_poly(df = df, predictor = 'x', poly.order = 3, orthogonal = TRUE, draw.poly = FALSE)
full_join(
    broom::tidy(lm(y~poly1, df))[,1:2] %>% 
        #mutate(estimate = paste(round(estimate,2), c("","**"))) %>% 
        rename(`y~poly1` = estimate),
    broom::tidy(lm(y~poly1+poly2, df))[,1:2] %>% 
        #mutate(estimate = paste(round(estimate,2), c("***","***","***"))) %>% 
        rename(`y~poly1+poly2` = estimate)
) %>% full_join(.,
                broom::tidy(lm(y~poly1+poly2+poly3, df))[,1:2] %>% 
                    #mutate(estimate = paste(round(estimate,2), c("***","***","***","***"))) %>% 
                    rename(`y~poly1+poly2+poly3` = estimate)
) %>% mutate_if(is.numeric,~round(.,2)) %>% 
    mutate_all(~ifelse(is.na(.), "-", .)) %>% 
    kableExtra::kable(caption = "Incremental addition of orthogonal polynomial terms") %>%
    kableExtra::kable_styling(full_width = FALSE)

```


:::statbox
**Remember what zero is!** 

With orthogonal polynomials, you need to be careful about interpreting coefficients. For raw polynomials the intercept remains the y-intercept (i.e., where the line hits the y-axis). The higher order terms can then be thought of from that starting point - e.g., "where $x$ is 2, $\widehat{y}$ is $\beta_0 + \beta_1 \cdot 2 + \beta_2 \cdot 2^2 + \beta_3 \cdot 2^3 ...$".  
<br>
For orthogonal polynomials, the interpretation becomes more tricky. The intercept is the overall average of y, the linear predictor is the linear change pivoting around the mean of $x$ (rather than $x = 0$), the quadratic term corresponds to the steepness of the quadratic curvature ("how curvy is it?"), the cubic term to the steepness at the inflection points ("how wiggly is it?"), and so on. 

::: 

## Some useful code from Dan

:::rtip

It's possible to use `poly()` internally in fitting our linear model, if we want:  
```{r eval=FALSE}
lm(y ~ poly(x, 3, raw = T), data = df)
```
<br>
Unfortunately, the coefficients will end up having long messy names `poly(x, 3, raw = T)[1]`, `poly(x, 3, raw = T)[2]` etc.   
<br>
It is probably nicer if we add the polynomials to our data itself. As it happens, Dan has provided a nice little function which attaches these as columns to our data, naming them `poly1`, `poly2`, etc. 
```{r include=FALSE}
set.seed(754)
mydata<-tibble(
  x = 1:10,
  y = x + 
  rnorm(1, mean = 100) * (x) +
  rnorm(1, mean = 0, sd = .01) * (x) ^ 2 +
  rnorm(1, mean = -1) * (x) ^ 3 + 
  rnorm(10)
) %>% rename(time=x)
```

```{r}
# import Dan's code and make it available in our own R session
# you must do this in every script you want to use this function
source("https://uoepsy.github.io/msmr/functions/code_poly.R")

mydata <- code_poly(df = mydata, predictor = 'time', poly.order = 3, 
                    orthogonal = FALSE, draw.poly = FALSE)
head(mydata)
```

Both will produce the same model output (but Dan's method produces these nice neat names for the coefficients!), and we can just put the terms into our model directly as `lm(y ~ poly1 + poly2 + poly3, data = mydata)`.  

`r optbegin("Demonstration", olabel=F,toggle=params$TOGGLE)`
```{r echo=FALSE}
set.seed(4)
df<-tibble(
  x = 1:10,
  y = x + 
  rnorm(1, mean = 100) * (x) +
  rnorm(1, mean = 0, sd = .01) * (x) ^ 2 +
  rnorm(1, mean = -1) * (x) ^ 3 + 
  rnorm(10)
)
```
Our data:  
```{r}
head(df)
```

A messy model:  
```{r}
m.messy <- lm(y ~ poly(x, 3, raw=T), data = df)
```

```{r echo=FALSE}
# broom::tidy(m.messy) %>% pander::pander()
```

```{r echo=FALSE}
broom::tidy(m.messy) %>% gt::gt()
```

Dan's code, and a neat model:  

```{r}
df <- code_poly(df = df, predictor = 'x', poly.order = 3, 
                orthogonal = FALSE, draw.poly = FALSE)
mDan <- lm(y ~ poly1 + poly2 + poly3, data = df)
```

```{r echo=FALSE}
# broom::tidy(mDan) %>% pander::pander()
```

```{r echo=FALSE}
broom::tidy(mDan) %>% gt::gt()
```

`r optend()`
:::




