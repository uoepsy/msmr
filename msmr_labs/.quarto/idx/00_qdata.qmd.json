{"title":"Questionnaire Data Wrangling","markdown":{"yaml":{"title":"Questionnaire Data Wrangling","params":{"SHOW_SOLS":true,"TOGGLE":true},"editor_options":{"chunk_output_type":"inline"}},"headingText":"Variable names","containsRefs":false,"markdown":"\n\n```{r}\n#| label: setup\n#| include: false\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nlibrary(tidyverse)\nlibrary(patchwork)\nxaringanExtra::use_panelset()\n```\n\nQuestionnaire data often comes to us in 'wide' format, which is often how we want it for many of the analytical methods we use with questionnaire data. However, working with data in the wide format comes with some specific challenges that generally arise because we have lots and lots of variables. \n\nBelow we will walk through some of the common ways we want to wrangle and clean questionnaire data.  \n\n\n\nVery often, the data might come to us with huge long names that correspond to the question being asked.  \nFor instance: \n```{r}\n#| eval: false\n#| echo: false\nsurvdat <- read_csv(\"data/surveywrangle.csv\") |> mutate(ppt = 1:n())\nsurvdat <- survdat[,c(60,3:52)]\nnames(survdat) <- gsub(\"Describe yourself as you generally are now, not as you wish to be in the future. Describe yourself as you honestly see yourself, in relation to other people you know of the same age and sex as you are. Remember that responses are anonymised. Please indicate the accuracy for each statement in how it describes you.  \",\"\",names(survdat))\nsurvdat$age = round(runif(nrow(survdat),20,29))\nsurvdat$height = round(rnorm(nrow(survdat),168,12))\nsurvdat$height[3]<-NA\nsurvdat <- survdat |> relocate(age,height,.after=ppt)\n# write_csv(survdat, file=\"../../data/surveywrangle.csv\")\n```\n```{r}\nsurvdat <- read_csv(\"https://uoepsy.github.io/data/surveywrangle.csv\")\nhead(survdat)\n```\n\n\nOften, we want our variables to have some easier names to work with, e.g. \"q1\", \"q2\" etc.  \n\nBecause it's often important to keep track of what each question actually asks, it can be useful to create a little dictionary to map our new variable names to the current names.  \n\nIn our data, we have variables called `ppt`, `age` and `height`, and then 50 variables corresponding to 50 different questions.  \nWhat I plan to do is rename them to `ppt`,`age`,`height`,`q1`, `q2`, ..., `q50`.  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### what do `paste()/paste0()` do?   \n\nThe `paste` functions allow us to simply \"paste\" characters together:  \nBy default, `paste()` will separate these with a space:  \n```{r}\npaste(\"i have a dog called\", \"dougal\")\n```\nand `paste0()` will not separate them by anything:\n```{r}\npaste0(\"i have a dog called\", \"dougal\")\n```\n\nWe can paste the same thing to a set of things: \n```{r}\npaste(\"i have a dog called\", c(\"dougal\", \"rufus\",\"rosie\"))\n```\nWhich can be useful for quickly making a set of variable names: \n```{r}\npaste0(\"item_\",1:10)\n```\n\n:::\n\n\n```{r}\ndatadict <- \n  tibble(\n    # these are my proposed new names\n    variable = c(\"ppt\",\"age\",\"height\", \n                 paste0(\"q\", 1:50)),\n    # current names\n    question = names(survdat)\n  )\nhead(datadict)\n```\n\nIf we want to, we can write this to a .csv file so that we can keep it somewhere useful.\n```{r}\n#| eval: false\nwrite_csv(datadict, file = \"survey_dictionary.csv\")\n```\n\nNow we have created our record, we can actually change the names of the variables:  \n```{r}\nnames(survdat)[4:53] <- paste0(\"q\", 1:50)\nhead(survdat)\n```\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Variable recoding\n\nFirst things first, all of the questions are scored on a 5 point likert^[Technically this is pronounced \"LICK-URT\" and not \"LIE-KURT\". It's named after [Dr Rensis Likert](https://en.wikipedia.org/wiki/Rensis_Likert){target=\"_blank\"}, and that's how he pronounced his name!] scale. \n\nThe data has come out of whatever questionnaire software we used and it's showing the chosen response for each question in words, e.g. \"`r survdat$q1[6]`\". But we are going to turn them into numbers so that they are easier to work with.  \n\n```{r}\n#| echo: false\ntibble(\nresponse = c(\"Very Inaccurate\",\"Moderately Inaccurate\",\"Neither Accurate nor Inaccurate\",\"Moderately Accurate\",\"Very Accurate\"),\nscore = c(1:5)\n) %>% gt::gt()\n```\n\nYou might be shouting at the screen here that by turning these words into numbers we're about to turn a set of ordered categories into an interval scale. Is \"Moderately Inaccurate\" really 2 x \"Very Inaccurate\"? You might be right to have this intuition - it's a contentious issue! In psychology, in which questionnaire based methods are everywhere, an often used rule of thumb is that likert data with $\\geq 5$ levels can be treated as if they are continuous without unduly influencing results (see [Johnson, D.R., & Creech, J.C. (1983). Ordinal measures in multiple indicator models: A simulation study of categorization error](https://discovered.ed.ac.uk/permalink/f/1s15qcp/TN_cdi_crossref_primary_10_2307_2095231){target=\"_blank\"}).  \n\nLet's push on and see how we can do this sort of recoding.  \nFirst we'll do it for just one variable. As always in R, there are lots of ways to do the same thing. All of these approaches follows an if-else type logic - \"if we have 'moderately inaccurate', make it '2', and if we have 'very inaccurate, make it 1, and if ... \".  \n\n\n::::panelset\n:::panel\n#### ifelse()  \n\nThis is the most cumbersome way to do this logic as it requires multiple nested ifelse statements.  \nTo ensure that anything that isn't one of the 5 valid response options gets to be an NA, we have the final \"else\" specifying that if it's none of the prespecified options, make it an NA\n```{r}\nsurvdat |>\n  mutate(\n    q1 = ifelse(q1 == \"Very Inaccurate\", 1,\n                ifelse(q1 == \"Moderately Inaccurate\", 2, \n                       ifelse( q1 == \"Neither Accurate nor Inaccurate\", 3, \n                               ifelse(q1 == \"Moderately Accurate\", 4, \n                                      ifelse(q1 == \"Very Accurate\", 5, NA)))))\n  )\n```\n:::\n:::panel\n#### case_when\n\n`case_when()` follows this same logic as `ifelse()` but makes for easier reading (and writing). Each line is a statement saying \"if [variable] is equal to [value], then return [new value]\". The final entry here `TRUE ~ NA` is a bit like saying \"and if it is anything else, make it an NA\". \n\n```{r}\nsurvdat |>\n  mutate(\n    q1 = case_when(\n      q1 == \"Very Inaccurate\" ~ 1,\n      q1 == \"Moderately Inaccurate\" ~ 2,\n      q1 == \"Neither Accurate nor Inaccurate\" ~ 3,\n      q1 == \"Moderately Accurate\" ~ 4,\n      q1 == \"Very Accurate\" ~ 5,\n      TRUE ~ NA\n    )\n  )\n```\n:::\n:::panel\n#### case_match()\n\nThe `ifelse()` and `case_when()` functions are much more generalised - we can say \"if x is 1 make it 1, and if y is 2 make it 0, and if z is ... \".  \n\nHowever, in the task at hand, all of our \"if\" questions apply to the value of the same variable. The `case_match()` function is perfectly designed for this:  \n\n```{r}\nsurvdat |> \n  mutate(\n    q1 = case_match(q1, \n                \"Very Inaccurate\" ~ 1,\n                \"Moderately Inaccurate\" ~ 2,\n                \"Neither Accurate nor Inaccurate\" ~ 3,\n                \"Moderately Accurate\" ~ 4,\n                \"Very Accurate\" ~ 5)\n  )\n```\n\nIf we wanted to collapse levels, the syntax works like so:  \n```{r}\n#| eval: false\nsurvdat |> \n  mutate(\n    q1 = case_match(q1, \n                    c(\"Very Inaccurate\",\"Moderately Inaccurate\") ~ 1,\n                    \"Neither Accurate nor Inaccurate\" ~ 2,\n                    c(\"Moderately Accurate\",\"Very Accurate\") ~ 3\n    )\n  )\n```\n\n\n:::\n\n::::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Applying the same operation across variables\n\nNow that we know how to recode a variable, what if we want to do it for all 50 questions? We don't want to do it manually, because that would be hugely inefficient:  \n```{r}\n#| eval: false\nsurvdat |> mutate(\n  q1 = case_match(q1,\n    ...\n    ..\n    ...\n  ),\n  q2 = case_match(q2,\n    ...\n    ..\n    ...\n  ),\n  ..\n)\n\n```\n\nThere are various ways to do this, but the two main ones are by utilising __tidyverse__'s `across()` function, or by using the Base R `apply()` function.  \n\n::::panelset\n:::panel\n#### across()\n\nThe `across()` function works inside other tidyverse functions like `summarise()` and `mutate()`, and allows us to do the same operation across a set of columns.  \n\nThe syntax is (with either summarise or mutate):  \n```{r}\n#| eval: false\ndata |>\n  mutate(across(variables, operation))\n```\n\nAs an example, suppose i wanted to summarise across the first three variables (`ppt`,`age`, and `height`) and get the mean. We can either specify the column numbers, or a set of names, or use the `:` to choose all variables between two columns.  \nThese all do the same:  \n```{r}\n#| eval: false\nsurvdat |> summarise(across(1:3, mean))\nsurvdat |> summarise(across(c(ppt,age,height), mean))\nsurvdat |> summarise(across(c(ppt:height), mean))\n```\n```{r}\n#| echo: false\nsurvdat |> summarise(across(1:3, mean))\n```\n\nNote that we get an NA in the mean heights, because there is an NA in the data. So we need to specify that `na.rm=TRUE` when using the `mean()` function.  \nUnfortunately, this won't work:  \n```{r}\n#| error: true\nsurvdat |> summarise(across(1:3, mean(na.rm=T)))\n```\nThis is because when we open the brackets of `mean()`, it looks for the object we want to take the mean of. We can pass this through using `~` and `.`, like so: \n(You can kind of read the `.` as a place-holder for each variable)\n```{r}\nsurvdat |> summarise(across(1:3, ~mean(x=., na.rm=T)))\n```\n\n\n\nUsing this syntax, we can apply the recoding we have seen above, but do it for all of the variables from `q1` to `q50`. All at once. like magic!  \nNote, we're not summarising here (i.e. we're not summarising down into a single value, we're just wanting to mutate the existing variables):  \n```{r}\nsurvdat |> \n  mutate(across(q1:q50,\n                ~case_match(., \n                \"Very Inaccurate\" ~ 1,\n                \"Moderately Inaccurate\" ~ 2,\n                \"Neither Accurate nor Inaccurate\" ~ 3,\n                \"Moderately Accurate\" ~ 4,\n                \"Very Accurate\" ~ 5)\n  ))\n```\n\n:::\n:::panel\n#### apply()\n\nBase R (the non-tidyverse stuff) has some really useful functions of the `apply()` family, that can allow us to do the same thing (apply an operation across a set of columns).  \n\nFor `apply()`, we give it an object like a dataframe, and we give it the dimension that we wish to perform the operation over. If we choose 1, it will do it for each row, and if we choose 2, it will do it for each column.  \nSo if we want the mean of the first 3 columns:  \n```{r}\napply(survdat[,1:3], MARGIN=2, FUN=mean)\n```\n\nMuch like with `across()`, this doesn't work because `mean()` now wants x explicitly given:\n```{r}\n#| error: true\napply(survdat[,1:3], MARGIN=2, FUN=mean(na.rm=TRUE))\n```\nBut instead of the `~` and `.` stuff in tidyverse, the `apply()` wants us to explicitly define a little function, using `function()`.  \n```{r}\n#| error: true\napply(survdat[,1:3], MARGIN=2, FUN=function(x) mean(x, na.rm=TRUE))\n```\n(it's actually just convention that people use `function(x)`. we could use `function(kermit) mean(kermit, na.rm=TRUE)` and it would still work!)\n\nSo how do we do the recoding of all our questions? We simply apply a function like `case_match()` to each column! \n\n```{r}\n#| eval: false\nsurvdat[,4:53] <- apply(survdat[,4:53], MARGIN=2, FUN=function(x) \n  case_match(x, \n             \"Very Inaccurate\" ~ 1,\n             \"Moderately Inaccurate\" ~ 2,\n             \"Neither Accurate nor Inaccurate\" ~ 3,\n             \"Moderately Accurate\" ~ 4,\n             \"Very Accurate\" ~ 5)\n  )\nsurvdat\n```\n\n```{r}\n#| echo: false\nsurvdat[,4:53] <- apply(survdat[,4:53], MARGIN=2, FUN=function(x) \n  case_match(x, \n             \"Very Inaccurate\" ~ 1,\n             \"Moderately Inaccurate\" ~ 2,\n             \"Neither Accurate nor Inaccurate\" ~ 3,\n             \"Moderately Accurate\" ~ 4,\n             \"Very Accurate\" ~ 5)\n  )\nsurvdat\n```\n\n\n:::\n::::\n\n\n\n::: {.callout-caution collapse=\"true\"}\n#### optional: more complex functions\n\nWe can also define our custom functions outside of the use of `apply()`/`across()`, which can be useful if we have more complex functions. \n\nFor example, we can do the same recoding and _then_ standardise each variable, by explicitly defining a function that does that: \n```{r}\nrecodemysurvey <- function(question){\n  score = case_match(question, \n             \"Very Inaccurate\" ~ 1,\n             \"Moderately Inaccurate\" ~ 2,\n             \"Neither Accurate nor Inaccurate\" ~ 3,\n             \"Moderately Accurate\" ~ 4,\n             \"Very Accurate\" ~ 5)\n  score = (score - mean(score, na.rm = TRUE)) / sd(score, na.rm = TRUE)\n  return(score)\n}\n```\n\nAnd then using that function, either with:\n```{r}\n#| eval: false\nsurvdat |>\n  mutate(across(q1:q50, recodemysurvey))\n```\nor with:  \n```{r}\n#| eval: false\napply(survdat[,4:53], 2, recodemysurvey)\n```\n\n\n:::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Reverse coding\n\nIt's very common for questionnaires to have a combination of questions for a construct, some of which are positively phrased and some which are negatively phrased. The idea here is to avoid introducing biases such as a bias to agree more than to disagree.   \n\nTake, for instance, `q1` and `q6` in our data, which are both measuring Extraversion: \n\n```{r}\ndatadict |>\n  filter(variable %in% c(\"q1\",\"q6\"))\n```\n\nSomeone very extraverted might respond to `q1` with \"Very Accurate\", and `q6` with \"Very Inaccurate\".  \n\nOften when we have a set of questions, we will want to reverse code the negatively phrased ones in order to have them all in the same direction. I.e. once they are recoded into numbers, we want the value 5 to represent highly extraverted on _both_ `q1` and `q6`.   \n\nHow do we reverse? We want any value of 1 to become 5, any value of 2 to become 4, 3 stays 3, 4 becomes 2, and 5 becomes 1.  \nWe can just subtract the value from 6!  \n```{r}\n6-c(1,2,3,4,5)\n```\n\nSo to reverse code `q6`, we can simply subtract the variable from 6.  \n```{r}\nsurvdat |> \n  mutate(q6 = 6-q6)\n```\n\nBut we're going to want to do this for all the negatively phrased questions in our survey. If we take a look at the [inventory page of the IPIP](https://ipip.ori.org/new_ipip-50-item-scale.htm){target=\"_blank\"}, we can see that these are all the even questions from 2 to 38, and then questions 39, 44, 46, and 49.  \n\nThat's a frustrating set!  \nLet's find a way to capture those. `seq(2,38,2)` will give us a sequence from 2 to 38 in steps of 2. So that gives us most of them. We can then just combine that with the other ones, and put \"q\" in front of each one to give us the variable names:  \n```{r}\nneg_items <- paste0(\"q\", c(seq(2,38,2),39,44,46,49))\nneg_items\n```\n\n::::panelset\n:::panel\n#### using `across()`\n```{r}\nsurvdat |> \n  mutate(across(all_of(neg_items),~6-.))\n```\n\n:::\n:::panel\n#### using `apply()`\n\n```{r}\nsurvdat[,neg_items] <- apply(survdat[,neg_items], 2, function(x) 6-x)\nsurvdat\n```\n\n:::\n::::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Row scoring  \n\nVery often, people want to calculate a scale score. For instance, if people responded to each of 7 questions for a scale of generalised anxiety, then we would want to calculate a 'generalised anxiety score' by adding up their responses 5+1+2+4+4+3+5 = 24.  \n\nThere are handy functions that can do quick row scoring: `rowSums()` and `rowMeans()`.  \n\nFor instance, to calculate each person's (each row of our data is a person) sum of the questions 1 to 5, we can use any of:  \n```{r}\n#| eval: false\n# tidyverse\nsurvdat |> select(q1:q5) |> rowSums()\n# indexing:\nrowSums(survdat[,c(\"q1\",\"q2\",\"q3\",\"q4\",\"q5\")])\n# concise indexing\nrowSums(survdat[, paste0(\"q\",1:5)])\n```\n```{r}\n#| echo: false\nrowSums(survdat[, paste0(\"q\",1:5)])\n```\n\nFrom the [inventory page of the IPIP](https://ipip.ori.org/new_ipip-50-item-scale.htm){target=\"_blank\"}, we can see that the questions are ordered such that questions 1, 6, 11, ..., all correspond to Extraversion, questions 2, 7, 12, ... all correspond to Agreeableness, and so on.  \n\nWe can use things like `seq()` to capture the relevant numbers of each question:\n```{r}\n# sequence from 1 to 50 in steps of 5\nseq(1,50,5) \n# sequence from 1 to 50 in steps of 5\nseq(2,50,5) \n```\n\n\nWhich means we can get the scores for each personality trait using something such as: \n\n```{r}\nsurvdat$extr <- rowSums(survdat[, paste0(\"q\",seq(1,50,5))])\nsurvdat$agree <- rowSums(survdat[, paste0(\"q\",seq(2,50,5))])\nsurvdat$consc <- rowSums(survdat[, paste0(\"q\",seq(3,50,5))])\nsurvdat$emot_s <- rowSums(survdat[, paste0(\"q\",seq(4,50,5))])\nsurvdat$imagin <- rowSums(survdat[, paste0(\"q\",seq(5,50,5))])\n```\n\nAnd we can quickly examine all our scale scores:  \n```{r}\nlibrary(psych)\nsurvdat |> \n  select(extr:imagin) |>\n  pairs.panels()\n```\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# More Rowwise Stuff\n\nWe can also find out useful information for each row about things like how much missingness there is:  \n```{r}\n# is.na will turn all NA entries to \"TRUE\", and all non-missing values to FALSE. \n# then we sum them up across the rows and it will give us how many NAs are in each row, across the 50 questions!  \nrowSums( is.na( survdat[, paste0(\"q\",1:50)] ) )\n```\n\n\nOccasionally, you might find that you want to do row-wise operations that don't have easy functions like `rowSums`. \nIn these cases, the tidyverse function `rowwise()` can be useful in that it applies an operation to one row at a time: \n\n```{r}\nsurvdat |> \n  rowwise() |>\n  mutate(\n    # find the minimum score given for each row\n    maxscore = min(across(q1:q50)), \n    # put the column after the height column\n    .after = height\n  )\n```\n\nAlternatively, `apply()` to the rescue again!  \n`MARGIN = 1` here applies the operation across rows:  \n```{r}\napply(survdat[,paste0(\"q\",1:50)], MARGIN = 1, FUN = min)\n```\n\n\n\n\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\n```{r}\n#| label: setup\n#| include: false\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nlibrary(tidyverse)\nlibrary(patchwork)\nxaringanExtra::use_panelset()\n```\n\nQuestionnaire data often comes to us in 'wide' format, which is often how we want it for many of the analytical methods we use with questionnaire data. However, working with data in the wide format comes with some specific challenges that generally arise because we have lots and lots of variables. \n\nBelow we will walk through some of the common ways we want to wrangle and clean questionnaire data.  \n\n\n# Variable names\n\nVery often, the data might come to us with huge long names that correspond to the question being asked.  \nFor instance: \n```{r}\n#| eval: false\n#| echo: false\nsurvdat <- read_csv(\"data/surveywrangle.csv\") |> mutate(ppt = 1:n())\nsurvdat <- survdat[,c(60,3:52)]\nnames(survdat) <- gsub(\"Describe yourself as you generally are now, not as you wish to be in the future. Describe yourself as you honestly see yourself, in relation to other people you know of the same age and sex as you are. Remember that responses are anonymised. Please indicate the accuracy for each statement in how it describes you.  \",\"\",names(survdat))\nsurvdat$age = round(runif(nrow(survdat),20,29))\nsurvdat$height = round(rnorm(nrow(survdat),168,12))\nsurvdat$height[3]<-NA\nsurvdat <- survdat |> relocate(age,height,.after=ppt)\n# write_csv(survdat, file=\"../../data/surveywrangle.csv\")\n```\n```{r}\nsurvdat <- read_csv(\"https://uoepsy.github.io/data/surveywrangle.csv\")\nhead(survdat)\n```\n\n\nOften, we want our variables to have some easier names to work with, e.g. \"q1\", \"q2\" etc.  \n\nBecause it's often important to keep track of what each question actually asks, it can be useful to create a little dictionary to map our new variable names to the current names.  \n\nIn our data, we have variables called `ppt`, `age` and `height`, and then 50 variables corresponding to 50 different questions.  \nWhat I plan to do is rename them to `ppt`,`age`,`height`,`q1`, `q2`, ..., `q50`.  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### what do `paste()/paste0()` do?   \n\nThe `paste` functions allow us to simply \"paste\" characters together:  \nBy default, `paste()` will separate these with a space:  \n```{r}\npaste(\"i have a dog called\", \"dougal\")\n```\nand `paste0()` will not separate them by anything:\n```{r}\npaste0(\"i have a dog called\", \"dougal\")\n```\n\nWe can paste the same thing to a set of things: \n```{r}\npaste(\"i have a dog called\", c(\"dougal\", \"rufus\",\"rosie\"))\n```\nWhich can be useful for quickly making a set of variable names: \n```{r}\npaste0(\"item_\",1:10)\n```\n\n:::\n\n\n```{r}\ndatadict <- \n  tibble(\n    # these are my proposed new names\n    variable = c(\"ppt\",\"age\",\"height\", \n                 paste0(\"q\", 1:50)),\n    # current names\n    question = names(survdat)\n  )\nhead(datadict)\n```\n\nIf we want to, we can write this to a .csv file so that we can keep it somewhere useful.\n```{r}\n#| eval: false\nwrite_csv(datadict, file = \"survey_dictionary.csv\")\n```\n\nNow we have created our record, we can actually change the names of the variables:  \n```{r}\nnames(survdat)[4:53] <- paste0(\"q\", 1:50)\nhead(survdat)\n```\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Variable recoding\n\nFirst things first, all of the questions are scored on a 5 point likert^[Technically this is pronounced \"LICK-URT\" and not \"LIE-KURT\". It's named after [Dr Rensis Likert](https://en.wikipedia.org/wiki/Rensis_Likert){target=\"_blank\"}, and that's how he pronounced his name!] scale. \n\nThe data has come out of whatever questionnaire software we used and it's showing the chosen response for each question in words, e.g. \"`r survdat$q1[6]`\". But we are going to turn them into numbers so that they are easier to work with.  \n\n```{r}\n#| echo: false\ntibble(\nresponse = c(\"Very Inaccurate\",\"Moderately Inaccurate\",\"Neither Accurate nor Inaccurate\",\"Moderately Accurate\",\"Very Accurate\"),\nscore = c(1:5)\n) %>% gt::gt()\n```\n\nYou might be shouting at the screen here that by turning these words into numbers we're about to turn a set of ordered categories into an interval scale. Is \"Moderately Inaccurate\" really 2 x \"Very Inaccurate\"? You might be right to have this intuition - it's a contentious issue! In psychology, in which questionnaire based methods are everywhere, an often used rule of thumb is that likert data with $\\geq 5$ levels can be treated as if they are continuous without unduly influencing results (see [Johnson, D.R., & Creech, J.C. (1983). Ordinal measures in multiple indicator models: A simulation study of categorization error](https://discovered.ed.ac.uk/permalink/f/1s15qcp/TN_cdi_crossref_primary_10_2307_2095231){target=\"_blank\"}).  \n\nLet's push on and see how we can do this sort of recoding.  \nFirst we'll do it for just one variable. As always in R, there are lots of ways to do the same thing. All of these approaches follows an if-else type logic - \"if we have 'moderately inaccurate', make it '2', and if we have 'very inaccurate, make it 1, and if ... \".  \n\n\n::::panelset\n:::panel\n#### ifelse()  \n\nThis is the most cumbersome way to do this logic as it requires multiple nested ifelse statements.  \nTo ensure that anything that isn't one of the 5 valid response options gets to be an NA, we have the final \"else\" specifying that if it's none of the prespecified options, make it an NA\n```{r}\nsurvdat |>\n  mutate(\n    q1 = ifelse(q1 == \"Very Inaccurate\", 1,\n                ifelse(q1 == \"Moderately Inaccurate\", 2, \n                       ifelse( q1 == \"Neither Accurate nor Inaccurate\", 3, \n                               ifelse(q1 == \"Moderately Accurate\", 4, \n                                      ifelse(q1 == \"Very Accurate\", 5, NA)))))\n  )\n```\n:::\n:::panel\n#### case_when\n\n`case_when()` follows this same logic as `ifelse()` but makes for easier reading (and writing). Each line is a statement saying \"if [variable] is equal to [value], then return [new value]\". The final entry here `TRUE ~ NA` is a bit like saying \"and if it is anything else, make it an NA\". \n\n```{r}\nsurvdat |>\n  mutate(\n    q1 = case_when(\n      q1 == \"Very Inaccurate\" ~ 1,\n      q1 == \"Moderately Inaccurate\" ~ 2,\n      q1 == \"Neither Accurate nor Inaccurate\" ~ 3,\n      q1 == \"Moderately Accurate\" ~ 4,\n      q1 == \"Very Accurate\" ~ 5,\n      TRUE ~ NA\n    )\n  )\n```\n:::\n:::panel\n#### case_match()\n\nThe `ifelse()` and `case_when()` functions are much more generalised - we can say \"if x is 1 make it 1, and if y is 2 make it 0, and if z is ... \".  \n\nHowever, in the task at hand, all of our \"if\" questions apply to the value of the same variable. The `case_match()` function is perfectly designed for this:  \n\n```{r}\nsurvdat |> \n  mutate(\n    q1 = case_match(q1, \n                \"Very Inaccurate\" ~ 1,\n                \"Moderately Inaccurate\" ~ 2,\n                \"Neither Accurate nor Inaccurate\" ~ 3,\n                \"Moderately Accurate\" ~ 4,\n                \"Very Accurate\" ~ 5)\n  )\n```\n\nIf we wanted to collapse levels, the syntax works like so:  \n```{r}\n#| eval: false\nsurvdat |> \n  mutate(\n    q1 = case_match(q1, \n                    c(\"Very Inaccurate\",\"Moderately Inaccurate\") ~ 1,\n                    \"Neither Accurate nor Inaccurate\" ~ 2,\n                    c(\"Moderately Accurate\",\"Very Accurate\") ~ 3\n    )\n  )\n```\n\n\n:::\n\n::::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Applying the same operation across variables\n\nNow that we know how to recode a variable, what if we want to do it for all 50 questions? We don't want to do it manually, because that would be hugely inefficient:  \n```{r}\n#| eval: false\nsurvdat |> mutate(\n  q1 = case_match(q1,\n    ...\n    ..\n    ...\n  ),\n  q2 = case_match(q2,\n    ...\n    ..\n    ...\n  ),\n  ..\n)\n\n```\n\nThere are various ways to do this, but the two main ones are by utilising __tidyverse__'s `across()` function, or by using the Base R `apply()` function.  \n\n::::panelset\n:::panel\n#### across()\n\nThe `across()` function works inside other tidyverse functions like `summarise()` and `mutate()`, and allows us to do the same operation across a set of columns.  \n\nThe syntax is (with either summarise or mutate):  \n```{r}\n#| eval: false\ndata |>\n  mutate(across(variables, operation))\n```\n\nAs an example, suppose i wanted to summarise across the first three variables (`ppt`,`age`, and `height`) and get the mean. We can either specify the column numbers, or a set of names, or use the `:` to choose all variables between two columns.  \nThese all do the same:  \n```{r}\n#| eval: false\nsurvdat |> summarise(across(1:3, mean))\nsurvdat |> summarise(across(c(ppt,age,height), mean))\nsurvdat |> summarise(across(c(ppt:height), mean))\n```\n```{r}\n#| echo: false\nsurvdat |> summarise(across(1:3, mean))\n```\n\nNote that we get an NA in the mean heights, because there is an NA in the data. So we need to specify that `na.rm=TRUE` when using the `mean()` function.  \nUnfortunately, this won't work:  \n```{r}\n#| error: true\nsurvdat |> summarise(across(1:3, mean(na.rm=T)))\n```\nThis is because when we open the brackets of `mean()`, it looks for the object we want to take the mean of. We can pass this through using `~` and `.`, like so: \n(You can kind of read the `.` as a place-holder for each variable)\n```{r}\nsurvdat |> summarise(across(1:3, ~mean(x=., na.rm=T)))\n```\n\n\n\nUsing this syntax, we can apply the recoding we have seen above, but do it for all of the variables from `q1` to `q50`. All at once. like magic!  \nNote, we're not summarising here (i.e. we're not summarising down into a single value, we're just wanting to mutate the existing variables):  \n```{r}\nsurvdat |> \n  mutate(across(q1:q50,\n                ~case_match(., \n                \"Very Inaccurate\" ~ 1,\n                \"Moderately Inaccurate\" ~ 2,\n                \"Neither Accurate nor Inaccurate\" ~ 3,\n                \"Moderately Accurate\" ~ 4,\n                \"Very Accurate\" ~ 5)\n  ))\n```\n\n:::\n:::panel\n#### apply()\n\nBase R (the non-tidyverse stuff) has some really useful functions of the `apply()` family, that can allow us to do the same thing (apply an operation across a set of columns).  \n\nFor `apply()`, we give it an object like a dataframe, and we give it the dimension that we wish to perform the operation over. If we choose 1, it will do it for each row, and if we choose 2, it will do it for each column.  \nSo if we want the mean of the first 3 columns:  \n```{r}\napply(survdat[,1:3], MARGIN=2, FUN=mean)\n```\n\nMuch like with `across()`, this doesn't work because `mean()` now wants x explicitly given:\n```{r}\n#| error: true\napply(survdat[,1:3], MARGIN=2, FUN=mean(na.rm=TRUE))\n```\nBut instead of the `~` and `.` stuff in tidyverse, the `apply()` wants us to explicitly define a little function, using `function()`.  \n```{r}\n#| error: true\napply(survdat[,1:3], MARGIN=2, FUN=function(x) mean(x, na.rm=TRUE))\n```\n(it's actually just convention that people use `function(x)`. we could use `function(kermit) mean(kermit, na.rm=TRUE)` and it would still work!)\n\nSo how do we do the recoding of all our questions? We simply apply a function like `case_match()` to each column! \n\n```{r}\n#| eval: false\nsurvdat[,4:53] <- apply(survdat[,4:53], MARGIN=2, FUN=function(x) \n  case_match(x, \n             \"Very Inaccurate\" ~ 1,\n             \"Moderately Inaccurate\" ~ 2,\n             \"Neither Accurate nor Inaccurate\" ~ 3,\n             \"Moderately Accurate\" ~ 4,\n             \"Very Accurate\" ~ 5)\n  )\nsurvdat\n```\n\n```{r}\n#| echo: false\nsurvdat[,4:53] <- apply(survdat[,4:53], MARGIN=2, FUN=function(x) \n  case_match(x, \n             \"Very Inaccurate\" ~ 1,\n             \"Moderately Inaccurate\" ~ 2,\n             \"Neither Accurate nor Inaccurate\" ~ 3,\n             \"Moderately Accurate\" ~ 4,\n             \"Very Accurate\" ~ 5)\n  )\nsurvdat\n```\n\n\n:::\n::::\n\n\n\n::: {.callout-caution collapse=\"true\"}\n#### optional: more complex functions\n\nWe can also define our custom functions outside of the use of `apply()`/`across()`, which can be useful if we have more complex functions. \n\nFor example, we can do the same recoding and _then_ standardise each variable, by explicitly defining a function that does that: \n```{r}\nrecodemysurvey <- function(question){\n  score = case_match(question, \n             \"Very Inaccurate\" ~ 1,\n             \"Moderately Inaccurate\" ~ 2,\n             \"Neither Accurate nor Inaccurate\" ~ 3,\n             \"Moderately Accurate\" ~ 4,\n             \"Very Accurate\" ~ 5)\n  score = (score - mean(score, na.rm = TRUE)) / sd(score, na.rm = TRUE)\n  return(score)\n}\n```\n\nAnd then using that function, either with:\n```{r}\n#| eval: false\nsurvdat |>\n  mutate(across(q1:q50, recodemysurvey))\n```\nor with:  \n```{r}\n#| eval: false\napply(survdat[,4:53], 2, recodemysurvey)\n```\n\n\n:::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Reverse coding\n\nIt's very common for questionnaires to have a combination of questions for a construct, some of which are positively phrased and some which are negatively phrased. The idea here is to avoid introducing biases such as a bias to agree more than to disagree.   \n\nTake, for instance, `q1` and `q6` in our data, which are both measuring Extraversion: \n\n```{r}\ndatadict |>\n  filter(variable %in% c(\"q1\",\"q6\"))\n```\n\nSomeone very extraverted might respond to `q1` with \"Very Accurate\", and `q6` with \"Very Inaccurate\".  \n\nOften when we have a set of questions, we will want to reverse code the negatively phrased ones in order to have them all in the same direction. I.e. once they are recoded into numbers, we want the value 5 to represent highly extraverted on _both_ `q1` and `q6`.   \n\nHow do we reverse? We want any value of 1 to become 5, any value of 2 to become 4, 3 stays 3, 4 becomes 2, and 5 becomes 1.  \nWe can just subtract the value from 6!  \n```{r}\n6-c(1,2,3,4,5)\n```\n\nSo to reverse code `q6`, we can simply subtract the variable from 6.  \n```{r}\nsurvdat |> \n  mutate(q6 = 6-q6)\n```\n\nBut we're going to want to do this for all the negatively phrased questions in our survey. If we take a look at the [inventory page of the IPIP](https://ipip.ori.org/new_ipip-50-item-scale.htm){target=\"_blank\"}, we can see that these are all the even questions from 2 to 38, and then questions 39, 44, 46, and 49.  \n\nThat's a frustrating set!  \nLet's find a way to capture those. `seq(2,38,2)` will give us a sequence from 2 to 38 in steps of 2. So that gives us most of them. We can then just combine that with the other ones, and put \"q\" in front of each one to give us the variable names:  \n```{r}\nneg_items <- paste0(\"q\", c(seq(2,38,2),39,44,46,49))\nneg_items\n```\n\n::::panelset\n:::panel\n#### using `across()`\n```{r}\nsurvdat |> \n  mutate(across(all_of(neg_items),~6-.))\n```\n\n:::\n:::panel\n#### using `apply()`\n\n```{r}\nsurvdat[,neg_items] <- apply(survdat[,neg_items], 2, function(x) 6-x)\nsurvdat\n```\n\n:::\n::::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Row scoring  \n\nVery often, people want to calculate a scale score. For instance, if people responded to each of 7 questions for a scale of generalised anxiety, then we would want to calculate a 'generalised anxiety score' by adding up their responses 5+1+2+4+4+3+5 = 24.  \n\nThere are handy functions that can do quick row scoring: `rowSums()` and `rowMeans()`.  \n\nFor instance, to calculate each person's (each row of our data is a person) sum of the questions 1 to 5, we can use any of:  \n```{r}\n#| eval: false\n# tidyverse\nsurvdat |> select(q1:q5) |> rowSums()\n# indexing:\nrowSums(survdat[,c(\"q1\",\"q2\",\"q3\",\"q4\",\"q5\")])\n# concise indexing\nrowSums(survdat[, paste0(\"q\",1:5)])\n```\n```{r}\n#| echo: false\nrowSums(survdat[, paste0(\"q\",1:5)])\n```\n\nFrom the [inventory page of the IPIP](https://ipip.ori.org/new_ipip-50-item-scale.htm){target=\"_blank\"}, we can see that the questions are ordered such that questions 1, 6, 11, ..., all correspond to Extraversion, questions 2, 7, 12, ... all correspond to Agreeableness, and so on.  \n\nWe can use things like `seq()` to capture the relevant numbers of each question:\n```{r}\n# sequence from 1 to 50 in steps of 5\nseq(1,50,5) \n# sequence from 1 to 50 in steps of 5\nseq(2,50,5) \n```\n\n\nWhich means we can get the scores for each personality trait using something such as: \n\n```{r}\nsurvdat$extr <- rowSums(survdat[, paste0(\"q\",seq(1,50,5))])\nsurvdat$agree <- rowSums(survdat[, paste0(\"q\",seq(2,50,5))])\nsurvdat$consc <- rowSums(survdat[, paste0(\"q\",seq(3,50,5))])\nsurvdat$emot_s <- rowSums(survdat[, paste0(\"q\",seq(4,50,5))])\nsurvdat$imagin <- rowSums(survdat[, paste0(\"q\",seq(5,50,5))])\n```\n\nAnd we can quickly examine all our scale scores:  \n```{r}\nlibrary(psych)\nsurvdat |> \n  select(extr:imagin) |>\n  pairs.panels()\n```\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# More Rowwise Stuff\n\nWe can also find out useful information for each row about things like how much missingness there is:  \n```{r}\n# is.na will turn all NA entries to \"TRUE\", and all non-missing values to FALSE. \n# then we sum them up across the rows and it will give us how many NAs are in each row, across the 50 questions!  \nrowSums( is.na( survdat[, paste0(\"q\",1:50)] ) )\n```\n\n\nOccasionally, you might find that you want to do row-wise operations that don't have easy functions like `rowSums`. \nIn these cases, the tidyverse function `rowwise()` can be useful in that it applies an operation to one row at a time: \n\n```{r}\nsurvdat |> \n  rowwise() |>\n  mutate(\n    # find the minimum score given for each row\n    maxscore = min(across(q1:q50)), \n    # put the column after the height column\n    .after = height\n  )\n```\n\nAlternatively, `apply()` to the rescue again!  \n`MARGIN = 1` here applies the operation across rows:  \n```{r}\napply(survdat[,paste0(\"q\",1:50)], MARGIN = 1, FUN = min)\n```\n\n\n\n\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"include-in-header":["assets/toggling.html",{"text":"<link rel=\"stylesheet\" href=\"https://uoepsy.github.io/assets/css/ccfooter.css\" />\n"}],"number-sections":false,"output-file":"00_qdata.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","toc_float":true,"link-citations":true,"theme":["united","assets/style-labs.scss"],"title":"Questionnaire Data Wrangling","params":{"SHOW_SOLS":true,"TOGGLE":true},"editor_options":{"chunk_output_type":"inline"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}