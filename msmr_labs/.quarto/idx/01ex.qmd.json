{"title":"Week 1 Exercises: Intro to MLM","markdown":{"yaml":{"title":"Week 1 Exercises: Intro to MLM","params":{"SHOW_SOLS":true,"TOGGLE":true},"editor_options":{"chunk_output_type":"console"}},"headingText":"New Packages!","containsRefs":false,"markdown":"\n\n```{r}\n#| label: setup\n#| include: false\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(ggdist)\nxaringanExtra::use_panelset()\nqcounter <- function(){\n  if(!exists(\"qcounter_i\")){\n    qcounter_i <<- 1\n  }else{\n    qcounter_i <<- qcounter_i + 1\n  }\n  qcounter_i\n}\n```\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n\nThese are the main packages we're going to use in this block. It might make sense to install them now *if you do not have them already*\n\n+ __tidyverse__ : for organising data  \n+ __lme4__ : for fitting generalised linear mixed effects models\n+ __broom.mixed__ : tidying methods for mixed models\n+ __effects__ : for tabulating and graphing effects in linear models\n+ __lmerTest__: for quick p-values from mixed models\n+ __parameters__: various inferential methods for mixed models\n\n:::\n\n# A Toy Example  \n\n```{r}\n#| include: false\ntoyyear <- tribble(\n  ~toy_type,~year,\n  \"Barbie\",1959,\n  \"Farm Animals\",1955,\n  \"Furby\",1998,\n  \"G.I.Joe\",1964,\n  \"Lego Minifigures\",1979,\n  \"Minecraft\",2011,\n  \"My Little Pony\",1982,\n  \"Peppa Pig\",2004,\n  \"Playmobil\",1975,\n  \"Polly Pocket\",1983,\n  \"Power Rangers\",1993,\n  \"Rugrats\",1991,\n  \"Scooby Doo\",1969,\n  \"Sock Puppets\",1901,\n  \"Star Wars\",1977,\n  \"Stretch Armstrong\",1976,\n  \"SuperZings\",2018,\n  \"Teenage Mutant Ninja Turtles\",1990,\n  \"Toy Story\",1996,\n  \"Transformers\",1984\n) \ntoys_read <- read_csv(\"https://uoepsy.github.io/data/toyexample.csv\")\n\ntoy2 <- left_join(toys_read, toyyear) |>\n  select(toy_type, year, toy, hrs_week, R_AGE) |>\n  arrange(toy_type) |>\n  mutate(\n    R_AGE = round(pmax(0,scale(R_AGE)[,1]*3 + 7))\n  ) |>\n  filter(!toy %in% c(\"Sock 3\",\"Mr Sock\",\"Progressive Sock\"))\n\ntoy2[toy2$toy_type==\"Sock Puppets\",\"R_AGE\"]<-c(13,1,15)\n\n# write_csv(toy2, \"../../data/toy2.csv\")\n```\n\n\nFor our first foray into the multilevel model, we're going to start with little toy example, and we're just going to ask you to plot the predictions from a) a simple linear model, b) a model with a random intercept, and c) a model with random intercepts and slopes.  \n\nThis is to build the understanding of the structure of multilevel models. When it comes to actually building models for research purposes, it is not necessary to slowly build up the complexity in this way.  \n\n:::frame\n__Data: New Toys!__  \n  \nRecall the example from last semesters' USMR course, where the lectures explored linear regression with a toy dataset of how practice influences the reading age of toy characters (see [USMR Week 7 Lecture](https://uoepsy.github.io/usmr/2324/lectures/lecture06.html#/learning-to-read-1){target=\"_blank\"}). We're going to now broaden our scope to the investigation of how practice affects reading age for **all** toys (not just Martin's Playmobil characters).  \n\nYou can find a dataset at [https://uoepsy.github.io/data/toy2.csv](https://uoepsy.github.io/data/toy2.csv){target=\"_blank\"} containing information on 129 different toy characters that come from a selection of different families/types of toy. You can see the variables in the table below^[Image sources:<br>http://tophatsasquatch.com/2012-tmnt-classics-action-figures/<br>https://www.dezeen.com/2016/02/01/barbie-dolls-fashionista-collection-mattel-new-body-types/<br>https://www.wish.com/product/5da9bc544ab36314cfa7f70c<br>https://www.worldwideshoppingmall.co.uk/toys/jumbo-farm-animals.asp<br>https://www.overstock.com/Sports-Toys/NJ-Croce-Scooby-Doo-5pc.-Bendable-Figure-Set-with-Scooby-Doo-Shaggy-Daphne-Velma-and-Fred/28534567/product.html<br>https://tvtropes.org/pmwiki/pmwiki.php/Toys/Furby<br>https://www.fun.com/toy-story-4-figure-4-pack.html<br>https://www.johnlewis.com/lego-minifigures-71027-series-20-pack/p5079461].  \n<br>  \n\n:::: {.columns}\n::: {.column width=\"45%\"}\n```{r echo=FALSE, out.width=\"300px\",fig.align=\"center\"}\nknitr::include_graphics(\"images/toys.png\")\n```\n:::\n::: {.column width=\"10%\"}\n:::\n::: {.column width=\"45%\"}\n```{r echo=FALSE, message=FALSE,warning=FALSE}\nlibrary(gt)\ntibble(variable=names(toy2),\n       description=c(\"Type of Toy\",\"Year Released\",\"Character\",\"Hours of practice per week\",\"Reading Age\")\n) %>% gt()\n\n```\n:::\n::::\n\n:::\n\n`r qbegin(qcounter())`\nRead in the data and plot the relationship between hours-per-week practice (`hrs_week`) and reading age (`R_AGE`).  \nFacet the plot by the type of toy.  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\n\"facet\" is the key word here! See [1A #visualisations](01a_clustered.html#visualisations){target=\"_blank\"}\n\n:::\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n```{r}\nlibrary(tidyverse)\ntoy2 <- read_csv(\"https://uoepsy.github.io/data/toy2.csv\")\n\nhead(toy2)\n\nggplot(toy2,aes(x=hrs_week,y=R_AGE))+\n  geom_point()+\n  facet_wrap(~toy_type)\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nBelow is the code to fit a simple linear model and produce some diagnostic plots.  \nAfter running the code, do you think that we have violated any assumptions?  \n```{r}\n#| eval: false\nmod1 <- lm(R_AGE ~ hrs_week, data = toy2)\nplot(mod1)\n```\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\nWe have violated an assumption here, and we don't need to look at the plots to realise it! As it happens, the plots don't actually look _terrible_ (the scale-location plot is a bit meh, but other than that things look okay).  \n\nThe assumption we have violated is that of **independence**. This is something we know through our understanding of the sampling procedure that has led to this data. We have got a random sample of different types of toys (e.g. power-rangers, toy-story, furbies etc), and within those types, we have a random sample of characters.  \n\nBut it is entirely likely that the type of toy is going to influence their reading age (i.e. farm animals might read worse than playmobil, etc).  \n\nSo this is something we can't really \"see\" in the data - we have to *think*. What do we know about the data generating process? (i.e. the process that led to this data)\n\n```{r}\n#| eval: false\nmod1 <- lm(R_AGE ~ hrs_week, data = toy2)\nplot(mod1)\n```\n```{r}\n#| echo: false\nmod1 <- lm(R_AGE ~ hrs_week, data = toy2)\npar(mfrow=c(2,2));plot(mod1);par(mfrow=c(1,1))\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nThere are lots of ways in R to get predicted values for a linear model (e.g. we saw `augment()` a lot in USMR). \n\nThe simplest way is to use functions like `predict()` or `fitted()` (they do the same thing), which gives us a vector of predicted values, which we can append to our dataframe (provided we don't have missing data): \n```{r}\n#| eval: false\ndata$predictedvalues <- predict(model)\n```\n\nAdd the predictions from the linear model in the previous question to the facetted plot that you created in the earlier question. How well does the model fit each type of toy?  \n`r qend()`\n`r solbegin(label=\"1 - add predictions to data\", slabel=F,show=T, toggle=params$TOGGLE)`\nThis only works because we don't have missing data (and so the length of `predict(mod1)` is the same as `nrow(toy2)`, and the predictions are in the correct order)  \n```{r}\n# add predictions to data:\ntoy2$pred <- predict(mod1)\n```\n\n\n`r solend()`\n`r solbegin(label=\"2 - add predictions to the plot\", slabel=F,show=T, toggle=params$TOGGLE)`\n```{r}\n# plot both predictions and observations:\ntoy2 |>\n  ggplot(aes(x=hrs_week))+\n  geom_point(aes(y=R_AGE)) + # observations\n  geom_line(aes(y=pred)) + # predictions\n  facet_wrap(~toy_type)\n```\n`r solend()`\n\n\n`r qbegin(qcounter())`\nLoad the __lme4__ package, and fit a model with random intercepts for each toy type.  \n\nUsing either `predict()` again, or this time you can use `augment()` from the __broom.mixed__ package, plot the predicted values and the observations.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nYou can see a model with a random intercept fitted in [1B# fitting-multilevel-models-in-r](01b_lmm.html#fitting-multilevel-models-in-r){target=\"_blank\"}.  \n\n:::\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\nHere's our model, with a random intercept by toy-type:\n```{r}\nlibrary(lme4)\nlibrary(broom.mixed)\n\nmod2 <- lmer(R_AGE ~ 1 + hrs_week + (1 | toy_type), data = toy2)\n```\nWe can use `augment()` from the __broom.mixed__ package, and which gives us the variables in the model along with things like fitted values (in the `.fitted` column)\n```{r}\n#| eval: false\naugment(mod2)\n```\n```{r}\n#| echo: false\nprint(augment(mod2),n=5)\n```\n```{r}\naugment(mod2) |>\n  ggplot(aes(x=hrs_week))+\n  geom_point(aes(y=R_AGE)) + # observations\n  geom_line(aes(y=.fitted)) + # predictions\n  facet_wrap(~toy_type)\n```\n\nNote that the model predictions are now a lot better than they were for the single level linear model. The line has moved up for the \"Scooby Doos\", and down for the \"Farm Animals\", etc. But the lines are all still the same slope. The slope is \"fixed\".  \n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nNow fit a model with random intercepts *and* slopes for each toy type. \n\nAs before, plot the predicted values of this model alongside the observations\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n```{r}\nmod3 <- lmer(R_AGE ~ 1 + hrs_week + (1 + hrs_week| toy_type), \n             data = toy2)\n\naugment(mod3) |>\n  ggplot(aes(x=hrs_week))+\n  geom_point(aes(y=R_AGE)) + # observations\n  geom_line(aes(y=.fitted)) + # predictions\n  facet_wrap(~toy_type)\n```\n\nThis looks even better - the lines are at good heights and good angles for each type of toy. Why? Because we have modelled the intercept (line height) and slope of `hrs_week` (line angle) as varying across types of toy!  \n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nFinally, add a `geom_smooth` to the plot from the previous question (making sure that this is has `y=R_AGE`).  \nThis will add a separate linear model `lm()` line for each of the facets in the plot.  \n\nWhat differences (look closely!) do you notice between the predictions from the model with random intercepts and slopes, and the simple geom_smooths? \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nYou could try changing `col`, `lty`, and `lwd` to make things easier to see.  \n\nWhat we're doing here is showing to ourselves 'partial pooling' in action ([1B #partial-pooling](01b_lmm.html#partial-pooling){target=\"_blank\"}).  \n\n:::\n\n\n`r qend()`\n`r solbegin(label=\"1 - adding geom_smooths to the plot\", slabel=F,show=T, toggle=params$TOGGLE)`\nhere's the model we are using:\n```{r}\nmod3 <- lmer(R_AGE ~ 1 + hrs_week + (1 + hrs_week| toy_type), \n             data = toy2)\n```\n\nand here is our plot:\n```{r}\naugment(mod3) |>\n  ggplot(aes(x=hrs_week))+\n  geom_point(aes(y=R_AGE)) + # observations\n  geom_line(aes(y=.fitted)) + # predictions\n  geom_smooth(aes(y=R_AGE), method=lm, se=F) + # simple smooths\n  facet_wrap(~toy_type)\n```\n`r solend()`\n`r solbegin(label=\"2 - why?\", slabel=F,show=T, toggle=params$TOGGLE)`\nI've made it a bit clearer here by changing up the colours and  linewidths (`lwd`), and subsetting to just a select few of the toy types:  \n```{r}\naugment(mod3) |>\n  filter(toy_type %in% c(\"Farm Animals\",\"Scooby Doo\",\"Sock Puppets\",\"Polly Pocket\")) |>\n  ggplot(aes(x=hrs_week))+\n  geom_point(aes(y=R_AGE), alpha=.2) + # observations\n  geom_line(aes(y=.fitted), col=\"orange\", lwd=1) + # predictions\n  geom_smooth(aes(y=R_AGE), method=lm, se=F, lty=\"dashed\") + # simple smooths\n  facet_wrap(~toy_type)\n```\nFor most of the toy types things look pretty similar. However, for \"Sock Puppets\" (only has 3 data points) the model predicted slope is shrunk back towards the average. \nIt is also possible to see this in the \"Farm Animals\" and \"Scooby Doo\" - the shrinkage is more noticeable on these because they are further away from the average. \n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nHere is the model with the random intercepts (but not random slopes) that we fitted in an earlier question.  \n\nBelow is the code that produces a plot of the fitted values: \n\n::: {.callout-note collapse=\"true\"}\n#### A. Model Equation\n\n$$\n\\begin{align}\n\\text{For Toy }j\\text{ of Type }i & \\\\\n\\text{Level 1 (Toy):}& \\\\\n\\text{R\\_AGE}_{ij} &= b_{0i} + b_1 \\cdot \\text{hrs\\_week}_{ij} + \\epsilon_{ij} \\\\\n\\text{Level 2 (Type):}& \\\\\nb_{0i} &= \\gamma_{00} + \\zeta_{0i} \\\\\n\\text{Where:}& \\\\\n\\zeta_{0i} &\\sim N(0,\\sigma_{0}) \\\\\n\\varepsilon &\\sim N(0,\\sigma_{e}) \\\\\n\\end{align}\n\n$$  \n  \n  \n:::\n::: {.callout-note collapse=\"true\"}\n#### B. Model output\n\n```{r}\nmod2 <- lmer(R_AGE ~ 1 + hrs_week + (1 | toy_type), \n             data = toy2)\nsummary(mod2)\n```\n\n:::\n::: {.callout-note collapse=\"true\"}\n#### C. Plot of fitted values\n\n```{r}\naugment(mod2) |>\n  ggplot(aes(x=hrs_week, col=toy_type))+\n  geom_point(aes(y=R_AGE),alpha=.3) + # observations\n  geom_line(aes(y=.fitted)) + # predictions \n  geom_abline(intercept = fixef(mod2)[1], \n              slope = fixef(mod2)[2], lwd=1) +  # fixed effect line\n  guides(col=\"none\") + # remove legend\n  xlim(0,7) # extent to x=0\n\n```\n\n:::\n\nMatch the parameters from the model equation, as well as coefficients from model output, to the corresponding points on the plot of fitted values.  \n\n:::: {.columns}\n::: {.column width=\"20%\"}\n__Model Equation__  \n\n+ **A1:** $\\sigma_{0}$   \n+ **A2:** $\\sigma_{\\varepsilon}$  \n+ **A3:** $\\gamma_{00}$  \n+ **A4:** $b_{1}$  \n\n:::\n::: {.column width=\"20%\"}\n__Model Output__  \n\n+ **B1:** 0.7118  \n+ **B2:** 2.698  \n+ **B3:** 1.597  \n+ **B4:** 4.2594  \n\n:::\n::: {.column width=\"60%\"}\n__Plot of fitted values__  \n\n+ **C1:** the standard deviation of the distances from all the individual toy types lines to the black line  \n+ **C2:** where the black line cuts the y axis  \n+ **C3:** the slope of the black line  \n+ **C4:** the standard deviation of the distances from all the individual observations to the line for the toy type to which it belongs.  \n\n\n\n\n:::\n\n::::\n\n\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n- A1 = B2 = C1\n- A2 = B3 = C4\n- A3 = B4 = C2\n- A4 = B1 = C3\n\n`r solend()`\n\n\n\n\n<br>\n<div class=\"divider div-transparent div-dot\"></div>\n\n\n# Audio Interference in Executive Functioning\n\n```{r}\n#| include: false\nset.seed(5)\nn_groups = 30\nN = n_groups*3*5\ng = rep(1:n_groups, e = N/n_groups)\n\nw = rep(rep(letters[1:3],5),n_groups)\nw1 = model.matrix(lm(rnorm(N)~w))[,2]\nw2 = model.matrix(lm(rnorm(N)~w))[,3]\n\nb = rep(0:1, e = N/2)\n\nre0 = rnorm(n_groups, sd = 2)[g]\nre_w1  = rnorm(n_groups, sd = 1)[g]\nre_w2  = rnorm(n_groups, sd = 1)[g]\n\nlp = (0 + re0) + \n  (3)*b + \n  (0 + re_w1)*w1 +\n  (-2 + re_w2)*w2 + \n  (2)*b*w1 +\n  (-1)*b*w2\n  \ny = rnorm(N, mean = lp, sd = 1.5) # create a continuous target variable\n\ndf <- data.frame(w, g=factor(g),b, y)\nhead(df)\nwith(df,boxplot(y~interaction(w,b)))\n\nlibrary(tidyverse)\ndf %>% transmute(\n  PID = paste0(\"PPT_\",formatC(g,width=2,flag=0)),\n  audio = fct_recode(factor(w),\n                     no_audio = \"a\",\n                     white_noise = \"b\",\n                     music = \"c\"),\n  headphones = fct_recode(factor(b),\n                          speakers = \"0\",\n                          anc_headphones = \"1\"),\n  SDMT = pmax(0,round(35 + scale(y)[,1]*12))\n) %>% arrange(PID,audio,headphones) -> ef_music\n\nef_music <- ef_music %>% group_by(PID) %>%\n  mutate(trial_n = paste0(\"Trial_\",formatC(sample(1:15),width=2,flag=0))) %>%\n  arrange(PID,trial_n) %>% ungroup()\n\nefrep <- slice_sample(ef_music, prop = .8) %>% select(PID,trial_n,audio,headphones,SDMT)\n\n# write_csv(efrep |> select(-trial_n), file=\"../../data/efsdmt.csv\")\n```\n\n:::frame\n__Data: Audio interference in executive functioning__  \n\nThis data is from a simulated study that aims to investigate the following research question: \n\n> How do different types of audio interfere with executive functioning, and does this interference differ depending upon whether or not noise-cancelling headphones are used? \n\n`r length(unique(efrep$PID))` healthy volunteers each completed the Symbol Digit Modalities Test (SDMT) - a commonly used test to assess processing speed and motor speed - a total of 15 times. During the tests, participants listened to either no audio (5 tests), white noise (5 tests) or classical music (5 tests). Half the participants listened via active-noise-cancelling headphones, and the other half listened via speakers in the room. Unfortunately, lots of the tests were not administered correctly, and so not every participant has the full 15 trials worth of data.  \n\nThe data is available at [https://uoepsy.github.io/data/efsdmt.csv](https://uoepsy.github.io/data/efsdmt.csv).  \n\n```{r}\n#| echo: false\nefrep <- read_csv(\"https://uoepsy.github.io/data/efsdmt.csv\")\ntibble(variable=names(efrep),\n       description = c(\n         \"Participant ID\",\n         \"Audio heard during the test ('no_audio', 'white_noise','music')\",\n         \"Whether the participant listened via speakers in the room or via noise cancelling headphones\",\n         \"Symbol Digit Modalities Test (SDMT) score\")\n) %>% gt()\n```\n\n:::\n\n`r qbegin(qcounter())`\nHow many participants are there in the data?   \nHow many have complete data (15 trials)?  \nWhat is the average number of trials that participants completed? What is the minimum?   \nDoes every participant have _some_ data for each type of audio?  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nFunctions like `table()` and `count()` will likely be useful here. \n:::\n\n\n`r qend()`\n`r solbegin(label=\"1 - read in the data \", slabel=F,show=T, toggle=params$TOGGLE)`\n```{r}\nefdat <- read_csv(\"https://uoepsy.github.io/data/efsdmt.csv\")\nhead(efdat)\n```\n`r solend()`\n`r solbegin(label=\"2 - how many ppts?\", slabel=F,show=T, toggle=params$TOGGLE)`\nFor a quick \"how many?\", functions like `n_distinct()` can be handy:  \n```{r}\nn_distinct(efdat$PID)\n```\n\nWhich is essentially the same as asking: \n```{r}\nunique(efdat$PID) |> length()\n```\n\n\n`r solend()`\n`r solbegin(label=\"3 - how many observations per ppt?\", slabel=F,show=T, toggle=params$TOGGLE)`\nHere are the counts of trials for each participant. \n```{r}\n#| eval: false\nefdat |> \n  count(PID)\n```\n```{r}\n#| echo: false\nefdat |> \n  count(PID) |>\n  print(n=5)\n```\n\nWe can pass that to something like `summary()` to get a quick descriptive of the `n` column, and so we can see that no participant completed all 15 trials (max is 14). Everyone completed at least 10, and the median was 12. \n```{r}\nefdat |> \n  count(PID) |>\n  summary()\n```\n\nWe could also do this easily with things like:\n```{r}\ntable(efdat$PID) |> median()\n```\n\n`r solend()`\n`r solbegin(label=\"4 - how many observations for each audio type per ppt?\", slabel=F,show=T, toggle=params$TOGGLE)`\nFor this kind of thing I would typically default to using `table()` for smaller datasets, to see how many datapoints are in each combination of `PID` and `audio`:  \n```{r}\ntable(efdat$PID, efdat$audio)\n```\n\nFrom the above, we can see that everyone has data from $\\geq 2$ trials for a given audio type.  \n\n```{r}\ntable(efdat$PID, efdat$audio) |> min()\n```\n\n\n::: {.callout-tip collapse=\"true\"}\n#### a tidyverse way:\n\nWhen tables get too big, we can do the same thing with `count()`, but we need to make sure that we are working with factors, in order to summarise all possible combinations of groups (even empty ones)\n```{r}\nefdat |> \n  mutate(PID = factor(PID),\n         audio = factor(audio)) |>\n  # the .drop=FALSE means \"keep empty groups\"\n  count(PID,audio,.drop=FALSE) |> \n  summary()\n```\n\nThere are plenty of other ways (e.g., you could use combinations of `group_by()`, `summarise()`), so just pick one that makes sense to you.  \n\n:::\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nConsider the following questions about the study:  \n  \n- What is our outcome of interest?  \n- What variables are we seeking to investigate in terms of their impact on the outcome?    \n- What are the units of observations?  \n- Are the observations clustered/grouped? In what way?  \n- What varies *within* these clusters?  \n- What varies *between* these clusters?  \n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n- What is our outcome of interest?  \n    + __SDMT scores__  \n- What variables are we seeking to investigate in terms of their impact on the outcome?  \n    + __audio type__ and the interaction __audio type $\\times$ wearing headphones__\n- What are the units of observations?  \n    + __individual trials__  \n- What are the groups/clusters?  \n    + __participants__  \n- What varies *within* these clusters?  \n    + __the type of audio__    \n- What varies *between* these clusters?  \n    + __whether they listen via headphones or speakers__  \n\n`r solend()`\n\n`r qbegin(qcounter())`\nCalculate the ICC, using the `ICCbare()` function from the **ICC** package.  \n\nHow much of the variation in SDMT scores is attributable to participant level differences?  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nSee [1A #icc](01a_clustered.html#icc---quantifying-clustering-in-an-outcome-variable){target=\"_blank\"}, or look up the help documentation for `?ICCbare()`.  \n\n:::\n\n  \n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n`r (ICC::ICCbare(x = PID, y = SDMT, data = efdat)[[1]]*100) |> round()`% of the variance in SDMT scores is attributable to participant level differences.  \n```{r}\nlibrary(ICC)\nICCbare(x = PID, y = SDMT, data = efdat)\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nThe multilevel model that has only an intercept (and the grouping structure) specified is sometimes referred to as the \"null model\" (or \"intercept only model\").  \nBecause there are no predictors in the fixed effects there is just a single value (the intercept). All of the variance in the outcome gets modelled in the random effects part, and is partitioned into either 'variance between groups' or 'residual variance'. This means we can just use those estimates to calculate the ICC.  \n\nFor our executive functioning study, fit the null model use the output to calculate the ICC.  \nCompare it to the answer from the previous question (it should be pretty close!)\n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\n\n```{r}\n#| echo: false\nknitr::include_graphics(\"images/nullmod.png\")\n```\n\nThe formula for the ICC is:  \n$$\nICC = \\frac{\\sigma^2_{b}}{\\sigma^2_{b} + \\sigma^2_e} = \\frac{\\text{between-group variance}}{\\text{between-group variance}+\\text{within-group variance}}\n$$\n\n\n:::\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n```{r}\nnullmod <- lmer(SDMT ~ 1 + (1 | PID), data = efdat)\nsummary(nullmod)\n```\n```{r}\n#| echo: false\nrr = as.data.frame(VarCorr(nullmod))[,4]\n```\n\n$\\frac{`r round(rr[1],2)`}{`r round(rr[1],2)`+`r round(rr[2],2)`} = `r round(rr[1]/sum(rr),2)`$, or `r round(rr[1]/sum(rr),2)*100`% of the variance in SDMT scores is explained by participant differences.  \n\nThis matches (closely enough) with the `ICCbare()` function from the previous question! \n\n`r solend()`\n\n`r qbegin(qcounter())`\nMake factors and set the reference levels of the `audio` and `headphones` variables to \"no audio\" and \"speakers\" respectively.    \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nCan't remember about setting factors and reference levels? Check back to USMR materials!  \n\n:::\n\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n```{r}\nefdat <- efdat %>%\n  mutate(\n    audio = fct_relevel(factor(audio), \"no_audio\"),\n    headphones = fct_relevel(factor(headphones), \"speakers\")\n  )\n```\n\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nFit a multilevel model to address the aims of the study (copied below)\n\n> How do different types of audio interfere with executive functioning, and does this interference differ depending upon whether or not noise-cancelling headphones are used? \n \nSpecifying the model may feel like a lot, but try splitting it into three parts:  \n\n$$\n\\text{lmer(}\\overbrace{\\text{outcome }\\sim\\text{ fixed effects}}^1\\, + \\, (1 + \\underbrace{\\text{slopes}}_3\\, |\\, \\overbrace{\\text{grouping structure}}^2 )\n$$\n\n\n1. Just like the `lm()`s we have used in USMR, think about what we want to _test_. This should provide the outcome and the structure of our fixed effects.  \n2. Think about how the observations are clustered/grouped. This should tell us how to specify the grouping structure in the random effects.  \n3. Think about which slopes (i.e. which terms in our fixed effects) could feasibly vary between the clusters. This provides you with what to put in as random slopes.  \n\n`r qend()`\n`r solbegin(label=\"1 - fixed effects\", slabel=F,show=T, toggle=params$TOGGLE)`\n\nThe question  \n&nbsp;&nbsp;&nbsp; \"*How do different types of audio interfere with executive functioning*\"   means we are interested in the effects of audio type (`audio`) on executive functioning (`SDMT` scores), so we will want:\n\n```\nlmer(SDMT ~ audio ...\n```\n\nHowever, the research aim also asks    \n&nbsp;&nbsp;&nbsp; \"*... and does this interference differ depending upon whether or not noise-cancelling headphones are used?*\"  \nwhich suggests that we are interested in the interaction `SDMT ~ audio * headphones`  \n\n```\nlmer(SDMT ~ audio * headphones + ...   \n```\n\n`r solend()`\n`r solbegin(label=\"2 - hierarchical data structure\", slabel=F,show=T, toggle=params$TOGGLE)`\n\nThere are lots of ways that our data is grouped.  \nWe have:  \n\n- 3 different groups of audio type (`r paste(unique(efdat$audio),collapse=\", \")`)\n- 2 groups of listening condition (`r paste(unique(efdat$headphones),collapse=\", \")`)\n- 30 groups of participants (\"PPT_01\", \"PPT_02\", \"PPT_03\", ...) \n\nThe effects of audio type and headphones are both things we actually want to _test_ - these variables are in our fixed effects. The levels of audio and headphones are not just a random sample from a wider population of levels - they're a specific set of things we want to compare SDMT scores between.  \n\nCompare this with the participants - we don't care about if there is a difference in SDMT scores between e.g., \"PPT_03\" and \"PPT_28\". The participants themselves are just a sample of people that we have taken from a wider population. This makes thinking of \"by-participant random effects\" a sensible approach - we model differences between participants as a normal distribution of deviations around some average:    \n\n```\nlmer(SDMT ~ audio * headphones + (1 + ... | PID)  \n```\n\nThe minimum that we can include is the random intercept. What `(1|PID)` specifies is that \"participants vary in their SDMT scores\". This makes sense - we would expect some participants to have higher executive functioning (and so will tend to score high on the SDMT), and others to have lower functioning (and so tend to score lower).  \n\n\n`r solend()`\n`r solbegin(label=\"3 - random slopes\", slabel=F,show=T, toggle=params$TOGGLE)`\n\nWe can also include a random by-participant effect of `audio`.  \n`audio|PID` specifies that the effect of audio type on SDMT varies by participant. This seems feasible - music might be very distracting (and interfere a lot with the test) for some participants, but have a negligible effect for others.  \n\n```\nlmer(SDMT ~ audio * headphones + \n              (1 + audio | PID), data = efdat)\n```\n\n\n::: {.callout-tip collapse=\"true\"}\n#### Why can't we have `(headphones|PID)`?  \n\nWhy can we fit `(1 + audio | PID)` but not `(1 + headphones | PID)`, or both `(1 + audio + headphones | PID)` or `(1 + audio * headphones | PID)`?  \n\nRemember that `y ~ ... + (x | g)` is saying \"the slope of y~x varies by g\".  \nSuch a sentence only makes sense if each \"the slope of y~x\" is defined for every (or most) groups.  \n\nFor the `headphones` predictor, every participant is _either_ in the \"speakers\" condition _or_ the \"anc_headphones\" condition.  \nThis means that \"the effect of headphones on SDMT\" _doesn't exist_ for any single participant! This means it makes no sense to try and think of the effect as 'varying by participant'.  \n\nCompare this to the `audio` predictor, for the effect _does_ exist for a single given participant, therefore it is possible to think of it as being different for different participants (e.g. PPT_30's performance improves with white noise, but PPT_16's performance does not).  \n\nThe plots below may help to cement this idea:  \n\n```{r}\n#| echo: false\nlibrary(lattice)\nbwplot(SDMT~headphones|PID, data = efdat, scales=list(x=list(rot=90)))\n\nbwplot(SDMT~audio|PID, data = efdat, scales=list(x=list(rot=90)))\n```\n\n:::\n\n`r solend()`\n\n\n\n`r qbegin(qcounter())`\nWe now have a model, but we don't have any p-values or confidence intervals or anything - i.e. we have no inferential criteria on which to draw conclusions. There are a whole load of different methods available for drawing inferences from multilevel models, which means it can be a bit of a never-ending rabbit hole. For now, we'll just use the 'quick and easy' approach provided by the **lmerTest** package seen in the lectures.  \n\nUsing the **lmerTest** package, re-fit your model, and you should now get some p-values! \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nIf you use `library(lmerTest)` to load the package, then *every single* model you fit will show p-values calculated with the Satterthwaite method.  \nPersonally, I would rather this is not the case, so I often opt to fit specific models with these p-values without ever loading the package:  \n`modp <- lmerTest::lmer(y ~ 1 + x + ....`  \n\n:::\n\n::: {.callout-caution collapse=\"true\"}\n#### optional: a model comparison\n\nIf we want to go down the model comparison route, we just need to isolate the relevant part(s) of the model that we are interested in.  \n\nRemember, as we saw in USMR, model comparison is sometimes a useful way of testing a _set_ of coefficients. For instance, in this example the interaction involves estimating _two_ terms: \n`audiomusic:headphonesanc_headphones` and `audiowhite_noise:headphonesanc_headphones`.  \n\nTo test the interaction as a whole, we can create a model without the interaction, and then compare it. The `SATmodcomp()` function from the __pbkrtest__ package provides a way of conducting an F test with the same Satterthwaite method of approximating the degrees of freedom:  \n  \n```{r}\nsdmt_mod <- lmer(SDMT ~ audio * headphones + \n              (1 + audio | PID), data = efdat)\nsdmt_res <- lmer(SDMT ~ audio + headphones + \n                   (1 + audio | PID), data = efdat)\nlibrary(pbkrtest)\nSATmodcomp(largeModel = sdmt_mod, smallModel = sdmt_res)\n```\n\n:::\n\n\n\n`r qend()`\n\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n```{r}\nsdmt_mod <- lmerTest::lmer(SDMT ~ audio * headphones + \n              (1 + audio | PID), data = efdat)\n\nsummary(sdmt_mod)\n```\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\n\nWe've already seen in the example with the toys (above) that we can visualise the fitted values (model predictions) using things like `augment()` from the __broom.mixed__ package. But these were plotting all the cluster-specific values (i.e. our random effects), and what we are really interested in are the estimates of (and uncertainty around) our fixed effects.  \n\nUsing tools like the __effects__ package can provide us with the values of the outcome across levels of a specific fixed predictor (holding other predictors at their mean).   \n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n```{r}\nlibrary(effects)\neffect(term = \"audio*headphones\", mod = sdmt_mod) |>\n  as.data.frame() |>\n  ggplot(aes(x=audio,y=fit,\n             ymin=lower,ymax=upper,\n             col=headphones))+\n  geom_pointrange(size=1,lwd=1)\n```\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nNow we have some p-values and a plot, try to create a short write-up of the analysis and results.   \n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n\n\n\n```{r}\n#| echo: false\nres = as.data.frame(parameters::model_parameters(sdmt_mod, ci_method=\"s\"))\nres[,c(2,3,5,6,7,8)] <- apply(res[,c(2,3,5,6,7,8)], 2, function(x) round(x, 2))\nres[,9] <- format.pval(res[,9],eps=.001,digits=2)\nres[,9][!grepl(\"<\",res[,9])] <- paste0(\"=\",res[,9][!grepl(\"<\",res[,9])])\n```\n\n:::int\nSDMT scores were modelled using linear mixed effects regression, with fixed effects of audio-type (no audio/white noise/music, treatment coded with no audio as the reference level), audio delivery (speakers/ANC-headphones, treatment coded with speakers as the reference level) and their interaction. Participant-level random intercepts and random slopes of audio-type were also included. The model was fitted using the **lme4** package in R, and estimated with restricted estimation maximum likelihood (REML). Denominator degrees of freedom for all tests were approximated using the Satterthwaite method.  \n\nInclusion of the interaction between headphones and audio-type was found to improve model fit ($F(2, 26.9) = 11.05, p < .001$), suggesting that the interference of different types of audio on executive functioning is dependent upon whether the audio is presented through ANC-headphones or through speakers.  \nParticipants not wearing headphones and presented with no audio scored on average `r res[1,2]` on the SDMT. Listening to music via speakers was associated with lower scores ($b = `r res[2,2]`, t(`r res[2,8]`)=`r res[2,7]`, p `r res[2,9]`$) compared to no audio. White noise played via speakers was not associated with a difference in performance on the SDMT compared to no audio.  \n\nWithout any audio playing, wearing ANC-headphones was associated with higher SDMT scores compared to no headphones ($b = `r res[4,2]`, t(`r res[4,8]`)=`r res[4,7]`, p `r res[4,9]`$). This difference between headphones and speakers was also evident when listening to white-noise ($b = `r res[6,2]`, t(`r res[6,8]`)=`r res[6,7]`, p `r res[6,9]`$). The apparent detrimental influence of music was not found to differ depending on whether headphones were worn ($b = `r res[5,2]`, p `r res[5,9]`$). \n\nThese results suggest that while music appears to interfere with executive functioning (resulting in lower SDMT scores) regardless of whether it is heard through headphones or speakers, listening to white noise may actually improve executive functioning, but only when presented via headphones. Furthermore, there appears to be benefits for executive functioning from wearing ANC-headphones even when not-listening to audio, perhaps due to the noise cancellation. The pattern of findings are displayed in @fig-efplot.  \n\n\n```{r}\n#| label: fig-efplot\n#| fig-cap: \"Interaction between the type (no audio/white noise/music) and the delivery (speakers/ANC headphones) on executive functioning task (SDMT)\"\n#| echo: false\nplotfit <- effect(term = \"audio*headphones\", mod = sdmt_mod) |>\n  as.data.frame()\n\nggplot(efdat, aes(x=audio,y=SDMT,col=headphones))+\n  geom_jitter(height=0,width=.2,alpha=.3) +\n  geom_pointrange(data = plotfit, \n                  aes(y=fit,ymin=lower,ymax=upper),\n                  size=1,lwd=1) \n```\n:::\n`r solend()`\n\n\n\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\n```{r}\n#| label: setup\n#| include: false\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(ggdist)\nxaringanExtra::use_panelset()\nqcounter <- function(){\n  if(!exists(\"qcounter_i\")){\n    qcounter_i <<- 1\n  }else{\n    qcounter_i <<- qcounter_i + 1\n  }\n  qcounter_i\n}\n```\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n#### New Packages!\n\nThese are the main packages we're going to use in this block. It might make sense to install them now *if you do not have them already*\n\n+ __tidyverse__ : for organising data  \n+ __lme4__ : for fitting generalised linear mixed effects models\n+ __broom.mixed__ : tidying methods for mixed models\n+ __effects__ : for tabulating and graphing effects in linear models\n+ __lmerTest__: for quick p-values from mixed models\n+ __parameters__: various inferential methods for mixed models\n\n:::\n\n# A Toy Example  \n\n```{r}\n#| include: false\ntoyyear <- tribble(\n  ~toy_type,~year,\n  \"Barbie\",1959,\n  \"Farm Animals\",1955,\n  \"Furby\",1998,\n  \"G.I.Joe\",1964,\n  \"Lego Minifigures\",1979,\n  \"Minecraft\",2011,\n  \"My Little Pony\",1982,\n  \"Peppa Pig\",2004,\n  \"Playmobil\",1975,\n  \"Polly Pocket\",1983,\n  \"Power Rangers\",1993,\n  \"Rugrats\",1991,\n  \"Scooby Doo\",1969,\n  \"Sock Puppets\",1901,\n  \"Star Wars\",1977,\n  \"Stretch Armstrong\",1976,\n  \"SuperZings\",2018,\n  \"Teenage Mutant Ninja Turtles\",1990,\n  \"Toy Story\",1996,\n  \"Transformers\",1984\n) \ntoys_read <- read_csv(\"https://uoepsy.github.io/data/toyexample.csv\")\n\ntoy2 <- left_join(toys_read, toyyear) |>\n  select(toy_type, year, toy, hrs_week, R_AGE) |>\n  arrange(toy_type) |>\n  mutate(\n    R_AGE = round(pmax(0,scale(R_AGE)[,1]*3 + 7))\n  ) |>\n  filter(!toy %in% c(\"Sock 3\",\"Mr Sock\",\"Progressive Sock\"))\n\ntoy2[toy2$toy_type==\"Sock Puppets\",\"R_AGE\"]<-c(13,1,15)\n\n# write_csv(toy2, \"../../data/toy2.csv\")\n```\n\n\nFor our first foray into the multilevel model, we're going to start with little toy example, and we're just going to ask you to plot the predictions from a) a simple linear model, b) a model with a random intercept, and c) a model with random intercepts and slopes.  \n\nThis is to build the understanding of the structure of multilevel models. When it comes to actually building models for research purposes, it is not necessary to slowly build up the complexity in this way.  \n\n:::frame\n__Data: New Toys!__  \n  \nRecall the example from last semesters' USMR course, where the lectures explored linear regression with a toy dataset of how practice influences the reading age of toy characters (see [USMR Week 7 Lecture](https://uoepsy.github.io/usmr/2324/lectures/lecture06.html#/learning-to-read-1){target=\"_blank\"}). We're going to now broaden our scope to the investigation of how practice affects reading age for **all** toys (not just Martin's Playmobil characters).  \n\nYou can find a dataset at [https://uoepsy.github.io/data/toy2.csv](https://uoepsy.github.io/data/toy2.csv){target=\"_blank\"} containing information on 129 different toy characters that come from a selection of different families/types of toy. You can see the variables in the table below^[Image sources:<br>http://tophatsasquatch.com/2012-tmnt-classics-action-figures/<br>https://www.dezeen.com/2016/02/01/barbie-dolls-fashionista-collection-mattel-new-body-types/<br>https://www.wish.com/product/5da9bc544ab36314cfa7f70c<br>https://www.worldwideshoppingmall.co.uk/toys/jumbo-farm-animals.asp<br>https://www.overstock.com/Sports-Toys/NJ-Croce-Scooby-Doo-5pc.-Bendable-Figure-Set-with-Scooby-Doo-Shaggy-Daphne-Velma-and-Fred/28534567/product.html<br>https://tvtropes.org/pmwiki/pmwiki.php/Toys/Furby<br>https://www.fun.com/toy-story-4-figure-4-pack.html<br>https://www.johnlewis.com/lego-minifigures-71027-series-20-pack/p5079461].  \n<br>  \n\n:::: {.columns}\n::: {.column width=\"45%\"}\n```{r echo=FALSE, out.width=\"300px\",fig.align=\"center\"}\nknitr::include_graphics(\"images/toys.png\")\n```\n:::\n::: {.column width=\"10%\"}\n:::\n::: {.column width=\"45%\"}\n```{r echo=FALSE, message=FALSE,warning=FALSE}\nlibrary(gt)\ntibble(variable=names(toy2),\n       description=c(\"Type of Toy\",\"Year Released\",\"Character\",\"Hours of practice per week\",\"Reading Age\")\n) %>% gt()\n\n```\n:::\n::::\n\n:::\n\n`r qbegin(qcounter())`\nRead in the data and plot the relationship between hours-per-week practice (`hrs_week`) and reading age (`R_AGE`).  \nFacet the plot by the type of toy.  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\n\"facet\" is the key word here! See [1A #visualisations](01a_clustered.html#visualisations){target=\"_blank\"}\n\n:::\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n```{r}\nlibrary(tidyverse)\ntoy2 <- read_csv(\"https://uoepsy.github.io/data/toy2.csv\")\n\nhead(toy2)\n\nggplot(toy2,aes(x=hrs_week,y=R_AGE))+\n  geom_point()+\n  facet_wrap(~toy_type)\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nBelow is the code to fit a simple linear model and produce some diagnostic plots.  \nAfter running the code, do you think that we have violated any assumptions?  \n```{r}\n#| eval: false\nmod1 <- lm(R_AGE ~ hrs_week, data = toy2)\nplot(mod1)\n```\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\nWe have violated an assumption here, and we don't need to look at the plots to realise it! As it happens, the plots don't actually look _terrible_ (the scale-location plot is a bit meh, but other than that things look okay).  \n\nThe assumption we have violated is that of **independence**. This is something we know through our understanding of the sampling procedure that has led to this data. We have got a random sample of different types of toys (e.g. power-rangers, toy-story, furbies etc), and within those types, we have a random sample of characters.  \n\nBut it is entirely likely that the type of toy is going to influence their reading age (i.e. farm animals might read worse than playmobil, etc).  \n\nSo this is something we can't really \"see\" in the data - we have to *think*. What do we know about the data generating process? (i.e. the process that led to this data)\n\n```{r}\n#| eval: false\nmod1 <- lm(R_AGE ~ hrs_week, data = toy2)\nplot(mod1)\n```\n```{r}\n#| echo: false\nmod1 <- lm(R_AGE ~ hrs_week, data = toy2)\npar(mfrow=c(2,2));plot(mod1);par(mfrow=c(1,1))\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nThere are lots of ways in R to get predicted values for a linear model (e.g. we saw `augment()` a lot in USMR). \n\nThe simplest way is to use functions like `predict()` or `fitted()` (they do the same thing), which gives us a vector of predicted values, which we can append to our dataframe (provided we don't have missing data): \n```{r}\n#| eval: false\ndata$predictedvalues <- predict(model)\n```\n\nAdd the predictions from the linear model in the previous question to the facetted plot that you created in the earlier question. How well does the model fit each type of toy?  \n`r qend()`\n`r solbegin(label=\"1 - add predictions to data\", slabel=F,show=T, toggle=params$TOGGLE)`\nThis only works because we don't have missing data (and so the length of `predict(mod1)` is the same as `nrow(toy2)`, and the predictions are in the correct order)  \n```{r}\n# add predictions to data:\ntoy2$pred <- predict(mod1)\n```\n\n\n`r solend()`\n`r solbegin(label=\"2 - add predictions to the plot\", slabel=F,show=T, toggle=params$TOGGLE)`\n```{r}\n# plot both predictions and observations:\ntoy2 |>\n  ggplot(aes(x=hrs_week))+\n  geom_point(aes(y=R_AGE)) + # observations\n  geom_line(aes(y=pred)) + # predictions\n  facet_wrap(~toy_type)\n```\n`r solend()`\n\n\n`r qbegin(qcounter())`\nLoad the __lme4__ package, and fit a model with random intercepts for each toy type.  \n\nUsing either `predict()` again, or this time you can use `augment()` from the __broom.mixed__ package, plot the predicted values and the observations.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nYou can see a model with a random intercept fitted in [1B# fitting-multilevel-models-in-r](01b_lmm.html#fitting-multilevel-models-in-r){target=\"_blank\"}.  \n\n:::\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\nHere's our model, with a random intercept by toy-type:\n```{r}\nlibrary(lme4)\nlibrary(broom.mixed)\n\nmod2 <- lmer(R_AGE ~ 1 + hrs_week + (1 | toy_type), data = toy2)\n```\nWe can use `augment()` from the __broom.mixed__ package, and which gives us the variables in the model along with things like fitted values (in the `.fitted` column)\n```{r}\n#| eval: false\naugment(mod2)\n```\n```{r}\n#| echo: false\nprint(augment(mod2),n=5)\n```\n```{r}\naugment(mod2) |>\n  ggplot(aes(x=hrs_week))+\n  geom_point(aes(y=R_AGE)) + # observations\n  geom_line(aes(y=.fitted)) + # predictions\n  facet_wrap(~toy_type)\n```\n\nNote that the model predictions are now a lot better than they were for the single level linear model. The line has moved up for the \"Scooby Doos\", and down for the \"Farm Animals\", etc. But the lines are all still the same slope. The slope is \"fixed\".  \n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nNow fit a model with random intercepts *and* slopes for each toy type. \n\nAs before, plot the predicted values of this model alongside the observations\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n```{r}\nmod3 <- lmer(R_AGE ~ 1 + hrs_week + (1 + hrs_week| toy_type), \n             data = toy2)\n\naugment(mod3) |>\n  ggplot(aes(x=hrs_week))+\n  geom_point(aes(y=R_AGE)) + # observations\n  geom_line(aes(y=.fitted)) + # predictions\n  facet_wrap(~toy_type)\n```\n\nThis looks even better - the lines are at good heights and good angles for each type of toy. Why? Because we have modelled the intercept (line height) and slope of `hrs_week` (line angle) as varying across types of toy!  \n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nFinally, add a `geom_smooth` to the plot from the previous question (making sure that this is has `y=R_AGE`).  \nThis will add a separate linear model `lm()` line for each of the facets in the plot.  \n\nWhat differences (look closely!) do you notice between the predictions from the model with random intercepts and slopes, and the simple geom_smooths? \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nYou could try changing `col`, `lty`, and `lwd` to make things easier to see.  \n\nWhat we're doing here is showing to ourselves 'partial pooling' in action ([1B #partial-pooling](01b_lmm.html#partial-pooling){target=\"_blank\"}).  \n\n:::\n\n\n`r qend()`\n`r solbegin(label=\"1 - adding geom_smooths to the plot\", slabel=F,show=T, toggle=params$TOGGLE)`\nhere's the model we are using:\n```{r}\nmod3 <- lmer(R_AGE ~ 1 + hrs_week + (1 + hrs_week| toy_type), \n             data = toy2)\n```\n\nand here is our plot:\n```{r}\naugment(mod3) |>\n  ggplot(aes(x=hrs_week))+\n  geom_point(aes(y=R_AGE)) + # observations\n  geom_line(aes(y=.fitted)) + # predictions\n  geom_smooth(aes(y=R_AGE), method=lm, se=F) + # simple smooths\n  facet_wrap(~toy_type)\n```\n`r solend()`\n`r solbegin(label=\"2 - why?\", slabel=F,show=T, toggle=params$TOGGLE)`\nI've made it a bit clearer here by changing up the colours and  linewidths (`lwd`), and subsetting to just a select few of the toy types:  \n```{r}\naugment(mod3) |>\n  filter(toy_type %in% c(\"Farm Animals\",\"Scooby Doo\",\"Sock Puppets\",\"Polly Pocket\")) |>\n  ggplot(aes(x=hrs_week))+\n  geom_point(aes(y=R_AGE), alpha=.2) + # observations\n  geom_line(aes(y=.fitted), col=\"orange\", lwd=1) + # predictions\n  geom_smooth(aes(y=R_AGE), method=lm, se=F, lty=\"dashed\") + # simple smooths\n  facet_wrap(~toy_type)\n```\nFor most of the toy types things look pretty similar. However, for \"Sock Puppets\" (only has 3 data points) the model predicted slope is shrunk back towards the average. \nIt is also possible to see this in the \"Farm Animals\" and \"Scooby Doo\" - the shrinkage is more noticeable on these because they are further away from the average. \n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nHere is the model with the random intercepts (but not random slopes) that we fitted in an earlier question.  \n\nBelow is the code that produces a plot of the fitted values: \n\n::: {.callout-note collapse=\"true\"}\n#### A. Model Equation\n\n$$\n\\begin{align}\n\\text{For Toy }j\\text{ of Type }i & \\\\\n\\text{Level 1 (Toy):}& \\\\\n\\text{R\\_AGE}_{ij} &= b_{0i} + b_1 \\cdot \\text{hrs\\_week}_{ij} + \\epsilon_{ij} \\\\\n\\text{Level 2 (Type):}& \\\\\nb_{0i} &= \\gamma_{00} + \\zeta_{0i} \\\\\n\\text{Where:}& \\\\\n\\zeta_{0i} &\\sim N(0,\\sigma_{0}) \\\\\n\\varepsilon &\\sim N(0,\\sigma_{e}) \\\\\n\\end{align}\n\n$$  \n  \n  \n:::\n::: {.callout-note collapse=\"true\"}\n#### B. Model output\n\n```{r}\nmod2 <- lmer(R_AGE ~ 1 + hrs_week + (1 | toy_type), \n             data = toy2)\nsummary(mod2)\n```\n\n:::\n::: {.callout-note collapse=\"true\"}\n#### C. Plot of fitted values\n\n```{r}\naugment(mod2) |>\n  ggplot(aes(x=hrs_week, col=toy_type))+\n  geom_point(aes(y=R_AGE),alpha=.3) + # observations\n  geom_line(aes(y=.fitted)) + # predictions \n  geom_abline(intercept = fixef(mod2)[1], \n              slope = fixef(mod2)[2], lwd=1) +  # fixed effect line\n  guides(col=\"none\") + # remove legend\n  xlim(0,7) # extent to x=0\n\n```\n\n:::\n\nMatch the parameters from the model equation, as well as coefficients from model output, to the corresponding points on the plot of fitted values.  \n\n:::: {.columns}\n::: {.column width=\"20%\"}\n__Model Equation__  \n\n+ **A1:** $\\sigma_{0}$   \n+ **A2:** $\\sigma_{\\varepsilon}$  \n+ **A3:** $\\gamma_{00}$  \n+ **A4:** $b_{1}$  \n\n:::\n::: {.column width=\"20%\"}\n__Model Output__  \n\n+ **B1:** 0.7118  \n+ **B2:** 2.698  \n+ **B3:** 1.597  \n+ **B4:** 4.2594  \n\n:::\n::: {.column width=\"60%\"}\n__Plot of fitted values__  \n\n+ **C1:** the standard deviation of the distances from all the individual toy types lines to the black line  \n+ **C2:** where the black line cuts the y axis  \n+ **C3:** the slope of the black line  \n+ **C4:** the standard deviation of the distances from all the individual observations to the line for the toy type to which it belongs.  \n\n\n\n\n:::\n\n::::\n\n\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n- A1 = B2 = C1\n- A2 = B3 = C4\n- A3 = B4 = C2\n- A4 = B1 = C3\n\n`r solend()`\n\n\n\n\n<br>\n<div class=\"divider div-transparent div-dot\"></div>\n\n\n# Audio Interference in Executive Functioning\n\n```{r}\n#| include: false\nset.seed(5)\nn_groups = 30\nN = n_groups*3*5\ng = rep(1:n_groups, e = N/n_groups)\n\nw = rep(rep(letters[1:3],5),n_groups)\nw1 = model.matrix(lm(rnorm(N)~w))[,2]\nw2 = model.matrix(lm(rnorm(N)~w))[,3]\n\nb = rep(0:1, e = N/2)\n\nre0 = rnorm(n_groups, sd = 2)[g]\nre_w1  = rnorm(n_groups, sd = 1)[g]\nre_w2  = rnorm(n_groups, sd = 1)[g]\n\nlp = (0 + re0) + \n  (3)*b + \n  (0 + re_w1)*w1 +\n  (-2 + re_w2)*w2 + \n  (2)*b*w1 +\n  (-1)*b*w2\n  \ny = rnorm(N, mean = lp, sd = 1.5) # create a continuous target variable\n\ndf <- data.frame(w, g=factor(g),b, y)\nhead(df)\nwith(df,boxplot(y~interaction(w,b)))\n\nlibrary(tidyverse)\ndf %>% transmute(\n  PID = paste0(\"PPT_\",formatC(g,width=2,flag=0)),\n  audio = fct_recode(factor(w),\n                     no_audio = \"a\",\n                     white_noise = \"b\",\n                     music = \"c\"),\n  headphones = fct_recode(factor(b),\n                          speakers = \"0\",\n                          anc_headphones = \"1\"),\n  SDMT = pmax(0,round(35 + scale(y)[,1]*12))\n) %>% arrange(PID,audio,headphones) -> ef_music\n\nef_music <- ef_music %>% group_by(PID) %>%\n  mutate(trial_n = paste0(\"Trial_\",formatC(sample(1:15),width=2,flag=0))) %>%\n  arrange(PID,trial_n) %>% ungroup()\n\nefrep <- slice_sample(ef_music, prop = .8) %>% select(PID,trial_n,audio,headphones,SDMT)\n\n# write_csv(efrep |> select(-trial_n), file=\"../../data/efsdmt.csv\")\n```\n\n:::frame\n__Data: Audio interference in executive functioning__  \n\nThis data is from a simulated study that aims to investigate the following research question: \n\n> How do different types of audio interfere with executive functioning, and does this interference differ depending upon whether or not noise-cancelling headphones are used? \n\n`r length(unique(efrep$PID))` healthy volunteers each completed the Symbol Digit Modalities Test (SDMT) - a commonly used test to assess processing speed and motor speed - a total of 15 times. During the tests, participants listened to either no audio (5 tests), white noise (5 tests) or classical music (5 tests). Half the participants listened via active-noise-cancelling headphones, and the other half listened via speakers in the room. Unfortunately, lots of the tests were not administered correctly, and so not every participant has the full 15 trials worth of data.  \n\nThe data is available at [https://uoepsy.github.io/data/efsdmt.csv](https://uoepsy.github.io/data/efsdmt.csv).  \n\n```{r}\n#| echo: false\nefrep <- read_csv(\"https://uoepsy.github.io/data/efsdmt.csv\")\ntibble(variable=names(efrep),\n       description = c(\n         \"Participant ID\",\n         \"Audio heard during the test ('no_audio', 'white_noise','music')\",\n         \"Whether the participant listened via speakers in the room or via noise cancelling headphones\",\n         \"Symbol Digit Modalities Test (SDMT) score\")\n) %>% gt()\n```\n\n:::\n\n`r qbegin(qcounter())`\nHow many participants are there in the data?   \nHow many have complete data (15 trials)?  \nWhat is the average number of trials that participants completed? What is the minimum?   \nDoes every participant have _some_ data for each type of audio?  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nFunctions like `table()` and `count()` will likely be useful here. \n:::\n\n\n`r qend()`\n`r solbegin(label=\"1 - read in the data \", slabel=F,show=T, toggle=params$TOGGLE)`\n```{r}\nefdat <- read_csv(\"https://uoepsy.github.io/data/efsdmt.csv\")\nhead(efdat)\n```\n`r solend()`\n`r solbegin(label=\"2 - how many ppts?\", slabel=F,show=T, toggle=params$TOGGLE)`\nFor a quick \"how many?\", functions like `n_distinct()` can be handy:  \n```{r}\nn_distinct(efdat$PID)\n```\n\nWhich is essentially the same as asking: \n```{r}\nunique(efdat$PID) |> length()\n```\n\n\n`r solend()`\n`r solbegin(label=\"3 - how many observations per ppt?\", slabel=F,show=T, toggle=params$TOGGLE)`\nHere are the counts of trials for each participant. \n```{r}\n#| eval: false\nefdat |> \n  count(PID)\n```\n```{r}\n#| echo: false\nefdat |> \n  count(PID) |>\n  print(n=5)\n```\n\nWe can pass that to something like `summary()` to get a quick descriptive of the `n` column, and so we can see that no participant completed all 15 trials (max is 14). Everyone completed at least 10, and the median was 12. \n```{r}\nefdat |> \n  count(PID) |>\n  summary()\n```\n\nWe could also do this easily with things like:\n```{r}\ntable(efdat$PID) |> median()\n```\n\n`r solend()`\n`r solbegin(label=\"4 - how many observations for each audio type per ppt?\", slabel=F,show=T, toggle=params$TOGGLE)`\nFor this kind of thing I would typically default to using `table()` for smaller datasets, to see how many datapoints are in each combination of `PID` and `audio`:  \n```{r}\ntable(efdat$PID, efdat$audio)\n```\n\nFrom the above, we can see that everyone has data from $\\geq 2$ trials for a given audio type.  \n\n```{r}\ntable(efdat$PID, efdat$audio) |> min()\n```\n\n\n::: {.callout-tip collapse=\"true\"}\n#### a tidyverse way:\n\nWhen tables get too big, we can do the same thing with `count()`, but we need to make sure that we are working with factors, in order to summarise all possible combinations of groups (even empty ones)\n```{r}\nefdat |> \n  mutate(PID = factor(PID),\n         audio = factor(audio)) |>\n  # the .drop=FALSE means \"keep empty groups\"\n  count(PID,audio,.drop=FALSE) |> \n  summary()\n```\n\nThere are plenty of other ways (e.g., you could use combinations of `group_by()`, `summarise()`), so just pick one that makes sense to you.  \n\n:::\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nConsider the following questions about the study:  \n  \n- What is our outcome of interest?  \n- What variables are we seeking to investigate in terms of their impact on the outcome?    \n- What are the units of observations?  \n- Are the observations clustered/grouped? In what way?  \n- What varies *within* these clusters?  \n- What varies *between* these clusters?  \n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n- What is our outcome of interest?  \n    + __SDMT scores__  \n- What variables are we seeking to investigate in terms of their impact on the outcome?  \n    + __audio type__ and the interaction __audio type $\\times$ wearing headphones__\n- What are the units of observations?  \n    + __individual trials__  \n- What are the groups/clusters?  \n    + __participants__  \n- What varies *within* these clusters?  \n    + __the type of audio__    \n- What varies *between* these clusters?  \n    + __whether they listen via headphones or speakers__  \n\n`r solend()`\n\n`r qbegin(qcounter())`\nCalculate the ICC, using the `ICCbare()` function from the **ICC** package.  \n\nHow much of the variation in SDMT scores is attributable to participant level differences?  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nSee [1A #icc](01a_clustered.html#icc---quantifying-clustering-in-an-outcome-variable){target=\"_blank\"}, or look up the help documentation for `?ICCbare()`.  \n\n:::\n\n  \n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n`r (ICC::ICCbare(x = PID, y = SDMT, data = efdat)[[1]]*100) |> round()`% of the variance in SDMT scores is attributable to participant level differences.  \n```{r}\nlibrary(ICC)\nICCbare(x = PID, y = SDMT, data = efdat)\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nThe multilevel model that has only an intercept (and the grouping structure) specified is sometimes referred to as the \"null model\" (or \"intercept only model\").  \nBecause there are no predictors in the fixed effects there is just a single value (the intercept). All of the variance in the outcome gets modelled in the random effects part, and is partitioned into either 'variance between groups' or 'residual variance'. This means we can just use those estimates to calculate the ICC.  \n\nFor our executive functioning study, fit the null model use the output to calculate the ICC.  \nCompare it to the answer from the previous question (it should be pretty close!)\n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\n\n```{r}\n#| echo: false\nknitr::include_graphics(\"images/nullmod.png\")\n```\n\nThe formula for the ICC is:  \n$$\nICC = \\frac{\\sigma^2_{b}}{\\sigma^2_{b} + \\sigma^2_e} = \\frac{\\text{between-group variance}}{\\text{between-group variance}+\\text{within-group variance}}\n$$\n\n\n:::\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n```{r}\nnullmod <- lmer(SDMT ~ 1 + (1 | PID), data = efdat)\nsummary(nullmod)\n```\n```{r}\n#| echo: false\nrr = as.data.frame(VarCorr(nullmod))[,4]\n```\n\n$\\frac{`r round(rr[1],2)`}{`r round(rr[1],2)`+`r round(rr[2],2)`} = `r round(rr[1]/sum(rr),2)`$, or `r round(rr[1]/sum(rr),2)*100`% of the variance in SDMT scores is explained by participant differences.  \n\nThis matches (closely enough) with the `ICCbare()` function from the previous question! \n\n`r solend()`\n\n`r qbegin(qcounter())`\nMake factors and set the reference levels of the `audio` and `headphones` variables to \"no audio\" and \"speakers\" respectively.    \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nCan't remember about setting factors and reference levels? Check back to USMR materials!  \n\n:::\n\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n```{r}\nefdat <- efdat %>%\n  mutate(\n    audio = fct_relevel(factor(audio), \"no_audio\"),\n    headphones = fct_relevel(factor(headphones), \"speakers\")\n  )\n```\n\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nFit a multilevel model to address the aims of the study (copied below)\n\n> How do different types of audio interfere with executive functioning, and does this interference differ depending upon whether or not noise-cancelling headphones are used? \n \nSpecifying the model may feel like a lot, but try splitting it into three parts:  \n\n$$\n\\text{lmer(}\\overbrace{\\text{outcome }\\sim\\text{ fixed effects}}^1\\, + \\, (1 + \\underbrace{\\text{slopes}}_3\\, |\\, \\overbrace{\\text{grouping structure}}^2 )\n$$\n\n\n1. Just like the `lm()`s we have used in USMR, think about what we want to _test_. This should provide the outcome and the structure of our fixed effects.  \n2. Think about how the observations are clustered/grouped. This should tell us how to specify the grouping structure in the random effects.  \n3. Think about which slopes (i.e. which terms in our fixed effects) could feasibly vary between the clusters. This provides you with what to put in as random slopes.  \n\n`r qend()`\n`r solbegin(label=\"1 - fixed effects\", slabel=F,show=T, toggle=params$TOGGLE)`\n\nThe question  \n&nbsp;&nbsp;&nbsp; \"*How do different types of audio interfere with executive functioning*\"   means we are interested in the effects of audio type (`audio`) on executive functioning (`SDMT` scores), so we will want:\n\n```\nlmer(SDMT ~ audio ...\n```\n\nHowever, the research aim also asks    \n&nbsp;&nbsp;&nbsp; \"*... and does this interference differ depending upon whether or not noise-cancelling headphones are used?*\"  \nwhich suggests that we are interested in the interaction `SDMT ~ audio * headphones`  \n\n```\nlmer(SDMT ~ audio * headphones + ...   \n```\n\n`r solend()`\n`r solbegin(label=\"2 - hierarchical data structure\", slabel=F,show=T, toggle=params$TOGGLE)`\n\nThere are lots of ways that our data is grouped.  \nWe have:  \n\n- 3 different groups of audio type (`r paste(unique(efdat$audio),collapse=\", \")`)\n- 2 groups of listening condition (`r paste(unique(efdat$headphones),collapse=\", \")`)\n- 30 groups of participants (\"PPT_01\", \"PPT_02\", \"PPT_03\", ...) \n\nThe effects of audio type and headphones are both things we actually want to _test_ - these variables are in our fixed effects. The levels of audio and headphones are not just a random sample from a wider population of levels - they're a specific set of things we want to compare SDMT scores between.  \n\nCompare this with the participants - we don't care about if there is a difference in SDMT scores between e.g., \"PPT_03\" and \"PPT_28\". The participants themselves are just a sample of people that we have taken from a wider population. This makes thinking of \"by-participant random effects\" a sensible approach - we model differences between participants as a normal distribution of deviations around some average:    \n\n```\nlmer(SDMT ~ audio * headphones + (1 + ... | PID)  \n```\n\nThe minimum that we can include is the random intercept. What `(1|PID)` specifies is that \"participants vary in their SDMT scores\". This makes sense - we would expect some participants to have higher executive functioning (and so will tend to score high on the SDMT), and others to have lower functioning (and so tend to score lower).  \n\n\n`r solend()`\n`r solbegin(label=\"3 - random slopes\", slabel=F,show=T, toggle=params$TOGGLE)`\n\nWe can also include a random by-participant effect of `audio`.  \n`audio|PID` specifies that the effect of audio type on SDMT varies by participant. This seems feasible - music might be very distracting (and interfere a lot with the test) for some participants, but have a negligible effect for others.  \n\n```\nlmer(SDMT ~ audio * headphones + \n              (1 + audio | PID), data = efdat)\n```\n\n\n::: {.callout-tip collapse=\"true\"}\n#### Why can't we have `(headphones|PID)`?  \n\nWhy can we fit `(1 + audio | PID)` but not `(1 + headphones | PID)`, or both `(1 + audio + headphones | PID)` or `(1 + audio * headphones | PID)`?  \n\nRemember that `y ~ ... + (x | g)` is saying \"the slope of y~x varies by g\".  \nSuch a sentence only makes sense if each \"the slope of y~x\" is defined for every (or most) groups.  \n\nFor the `headphones` predictor, every participant is _either_ in the \"speakers\" condition _or_ the \"anc_headphones\" condition.  \nThis means that \"the effect of headphones on SDMT\" _doesn't exist_ for any single participant! This means it makes no sense to try and think of the effect as 'varying by participant'.  \n\nCompare this to the `audio` predictor, for the effect _does_ exist for a single given participant, therefore it is possible to think of it as being different for different participants (e.g. PPT_30's performance improves with white noise, but PPT_16's performance does not).  \n\nThe plots below may help to cement this idea:  \n\n```{r}\n#| echo: false\nlibrary(lattice)\nbwplot(SDMT~headphones|PID, data = efdat, scales=list(x=list(rot=90)))\n\nbwplot(SDMT~audio|PID, data = efdat, scales=list(x=list(rot=90)))\n```\n\n:::\n\n`r solend()`\n\n\n\n`r qbegin(qcounter())`\nWe now have a model, but we don't have any p-values or confidence intervals or anything - i.e. we have no inferential criteria on which to draw conclusions. There are a whole load of different methods available for drawing inferences from multilevel models, which means it can be a bit of a never-ending rabbit hole. For now, we'll just use the 'quick and easy' approach provided by the **lmerTest** package seen in the lectures.  \n\nUsing the **lmerTest** package, re-fit your model, and you should now get some p-values! \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nIf you use `library(lmerTest)` to load the package, then *every single* model you fit will show p-values calculated with the Satterthwaite method.  \nPersonally, I would rather this is not the case, so I often opt to fit specific models with these p-values without ever loading the package:  \n`modp <- lmerTest::lmer(y ~ 1 + x + ....`  \n\n:::\n\n::: {.callout-caution collapse=\"true\"}\n#### optional: a model comparison\n\nIf we want to go down the model comparison route, we just need to isolate the relevant part(s) of the model that we are interested in.  \n\nRemember, as we saw in USMR, model comparison is sometimes a useful way of testing a _set_ of coefficients. For instance, in this example the interaction involves estimating _two_ terms: \n`audiomusic:headphonesanc_headphones` and `audiowhite_noise:headphonesanc_headphones`.  \n\nTo test the interaction as a whole, we can create a model without the interaction, and then compare it. The `SATmodcomp()` function from the __pbkrtest__ package provides a way of conducting an F test with the same Satterthwaite method of approximating the degrees of freedom:  \n  \n```{r}\nsdmt_mod <- lmer(SDMT ~ audio * headphones + \n              (1 + audio | PID), data = efdat)\nsdmt_res <- lmer(SDMT ~ audio + headphones + \n                   (1 + audio | PID), data = efdat)\nlibrary(pbkrtest)\nSATmodcomp(largeModel = sdmt_mod, smallModel = sdmt_res)\n```\n\n:::\n\n\n\n`r qend()`\n\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n```{r}\nsdmt_mod <- lmerTest::lmer(SDMT ~ audio * headphones + \n              (1 + audio | PID), data = efdat)\n\nsummary(sdmt_mod)\n```\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\n\nWe've already seen in the example with the toys (above) that we can visualise the fitted values (model predictions) using things like `augment()` from the __broom.mixed__ package. But these were plotting all the cluster-specific values (i.e. our random effects), and what we are really interested in are the estimates of (and uncertainty around) our fixed effects.  \n\nUsing tools like the __effects__ package can provide us with the values of the outcome across levels of a specific fixed predictor (holding other predictors at their mean).   \n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n```{r}\nlibrary(effects)\neffect(term = \"audio*headphones\", mod = sdmt_mod) |>\n  as.data.frame() |>\n  ggplot(aes(x=audio,y=fit,\n             ymin=lower,ymax=upper,\n             col=headphones))+\n  geom_pointrange(size=1,lwd=1)\n```\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nNow we have some p-values and a plot, try to create a short write-up of the analysis and results.   \n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n\n\n\n```{r}\n#| echo: false\nres = as.data.frame(parameters::model_parameters(sdmt_mod, ci_method=\"s\"))\nres[,c(2,3,5,6,7,8)] <- apply(res[,c(2,3,5,6,7,8)], 2, function(x) round(x, 2))\nres[,9] <- format.pval(res[,9],eps=.001,digits=2)\nres[,9][!grepl(\"<\",res[,9])] <- paste0(\"=\",res[,9][!grepl(\"<\",res[,9])])\n```\n\n:::int\nSDMT scores were modelled using linear mixed effects regression, with fixed effects of audio-type (no audio/white noise/music, treatment coded with no audio as the reference level), audio delivery (speakers/ANC-headphones, treatment coded with speakers as the reference level) and their interaction. Participant-level random intercepts and random slopes of audio-type were also included. The model was fitted using the **lme4** package in R, and estimated with restricted estimation maximum likelihood (REML). Denominator degrees of freedom for all tests were approximated using the Satterthwaite method.  \n\nInclusion of the interaction between headphones and audio-type was found to improve model fit ($F(2, 26.9) = 11.05, p < .001$), suggesting that the interference of different types of audio on executive functioning is dependent upon whether the audio is presented through ANC-headphones or through speakers.  \nParticipants not wearing headphones and presented with no audio scored on average `r res[1,2]` on the SDMT. Listening to music via speakers was associated with lower scores ($b = `r res[2,2]`, t(`r res[2,8]`)=`r res[2,7]`, p `r res[2,9]`$) compared to no audio. White noise played via speakers was not associated with a difference in performance on the SDMT compared to no audio.  \n\nWithout any audio playing, wearing ANC-headphones was associated with higher SDMT scores compared to no headphones ($b = `r res[4,2]`, t(`r res[4,8]`)=`r res[4,7]`, p `r res[4,9]`$). This difference between headphones and speakers was also evident when listening to white-noise ($b = `r res[6,2]`, t(`r res[6,8]`)=`r res[6,7]`, p `r res[6,9]`$). The apparent detrimental influence of music was not found to differ depending on whether headphones were worn ($b = `r res[5,2]`, p `r res[5,9]`$). \n\nThese results suggest that while music appears to interfere with executive functioning (resulting in lower SDMT scores) regardless of whether it is heard through headphones or speakers, listening to white noise may actually improve executive functioning, but only when presented via headphones. Furthermore, there appears to be benefits for executive functioning from wearing ANC-headphones even when not-listening to audio, perhaps due to the noise cancellation. The pattern of findings are displayed in @fig-efplot.  \n\n\n```{r}\n#| label: fig-efplot\n#| fig-cap: \"Interaction between the type (no audio/white noise/music) and the delivery (speakers/ANC headphones) on executive functioning task (SDMT)\"\n#| echo: false\nplotfit <- effect(term = \"audio*headphones\", mod = sdmt_mod) |>\n  as.data.frame()\n\nggplot(efdat, aes(x=audio,y=SDMT,col=headphones))+\n  geom_jitter(height=0,width=.2,alpha=.3) +\n  geom_pointrange(data = plotfit, \n                  aes(y=fit,ymin=lower,ymax=upper),\n                  size=1,lwd=1) \n```\n:::\n`r solend()`\n\n\n\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"include-in-header":["assets/toggling.html"],"number-sections":false,"output-file":"01ex.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","toc_float":true,"link-citations":true,"theme":["united","assets/style-labs.scss"],"title":"Week 1 Exercises: Intro to MLM","params":{"SHOW_SOLS":true,"TOGGLE":true},"editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}