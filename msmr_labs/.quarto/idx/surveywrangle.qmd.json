{"title":"Data wrangling for surveys & questionnaires","markdown":{"yaml":{"title":"Data wrangling for surveys & questionnaires","author":"hello","params":{"SHOW_SOLS":true,"TOGGLE":true},"editor_options":{"chunk_output_type":"console"}},"headingText":"column names","containsRefs":false,"markdown":"\n\n```{r}\n#| label: setup\n#| include: false\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nlibrary(tidyverse)\nlibrary(patchwork)\nxaringanExtra::use_panelset()\n```\n\nQuestionnaire data often comes to us in 'wide' format, which is often how we want it for many of the analytical methods we use with questionnaire data. However, working with data in the wide format comes with some specific challenges that generally arise because we have lots and lots of variables. \n\nBelow we will walk through some of the common ways we want to wrangle and clean questionnaire data.  \n\n\n\nVery often, the data might come to us with huge long names that correspond to the question being asked.  \nFor instance: \n```{r}\nsurvdat <- read_csv(\"data/surveywrangle.csv\") |> mutate(ppt = 1:n())\nsurvdat <- survdat[,c(60,3:52)]\nnames(survdat) <- gsub(\"Describe yourself as you generally are now, not as you wish to be in the future. Describe yourself as you honestly see yourself, in relation to other people you know of the same age and sex as you are. Remember that responses are anonymised. Please indicate the accuracy for each statement in how it describes you.  \",\"\",names(survdat))\nhead(survdat)\n```\n\nOften, we want our variables to have some easier names to work with, e.g. \"q1\", \"q2\" etc.  \n\nBecause it's often important to keep track of what each question actually asks, it can be useful to create a little dictionary to map our new variable names to the current names.  \n\nIn our data, we have a variable called `ppt`, and then 50 variables corresponding to 50 different questions.  \nWhat I plan to do is rename them to `ppt`, `q1`, `q2`, ..., `q50`.  \n```{r}\ndatadict <- \n  tibble(\n    # these are my proposed new names\n    variable = c(\"ppt\", paste0(\"q\", 1:50)),\n    # current names\n    question = names(survdat)\n  )\nhead(datadict)\n```\n\nIf we want to, we can write this to a .csv file so that we can keep it somewhere useful.\n```{r}\n#| eval: false\nwrite_csv(datadict, file = \"survey_dictionary.csv\")\n```\n\nNow we have created our record, we can actually change the names of the variables:  \n```{r}\nnames(survdat) <- c(\"ppt\", paste0(\"q\", 1:50))\nhead(survdat)\n```\n\n# replacing values and recoding\n\nFirst things first, all of the questions are scored on a 5 point likert^[Technically this is pronounced \"LICK-URT\" and not \"LIE-KURT\". It's named after [Dr Rensis Likert](https://en.wikipedia.org/wiki/Rensis_Likert){target=\"_blank\"}, and that's how he pronounced his name!] scale. \n\nThe data has come out of whatever questionnaire software we used and it's showing the chosen response for each question in words, e.g. \"`r survdat$q1[6]`. But we are going to to treat them as numbers. \nYou might be shouting here that it looks like we're about to turn a set of ordered categories into some interval scale, and that \n\nsome statisticians might maintain that ordinal data is simply __not__ continuous, so we should never treat it as such. In psychology, much research using SEM centers around questionnaire data, which lends itself to *likert* data (for instance, \"strongly agree\",\"agree\",\"neither agree nor disagree\",\"disagree\",\"strongly disagree\"). An often used rule of thumb, is that likert data with $\\geq 5$ levels can be treated as if they are continuous without unduly influencing results (see [Johnson, D.R., & Creech, J.C. (1983). Ordinal measures in multiple indicator models: A simulation study of categorization error](https://discovered.ed.ac.uk/permalink/f/1s15qcp/TN_cdi_crossref_primary_10_2307_2095231)).  \n\n```{r}\n#| echo: false\ntibble(\nresponse = c(\"Very Inaccurate\",\"Moderately Inaccurate\",\"Neither Accurate nor Inaccurate\",\"Moderately Accurate\",\"Very Accurate\"),\nscore = c(1:5)\n) %>% gt::gt()\n```\n\nlet's see how we can do it for one question first: \nthe `recode()` function can be very useful, but there are lots of other approaches\n\n\n\n::::panelset\n:::panel\n#### recode\n\n\n```{r}\nsurvdat %>% \n  mutate(\n    q3 = recode(q3, \n                \"Very Inaccurate\" = 1,\n                \"Moderately Inaccurate\" = 2,\n                \"Neither Accurate nor Inaccurate\" = 3,\n                \"Moderately Accurate\" = 4,\n                \"Very Accurate\" = 5)\n  )\n```\n:::\n:::panel\n#### ifelse\nmuch more cumbersome as it requires multiple nested ifelse statements:\nalso, to ensure that anyhing that isn't one of the 5 valid response options gets to be an NA, we have the final \"else\" specifying that if it's none of the prespecified options, make it an NA\n```{r}\nsurvdat %>% \n  mutate(\n    q3 = ifelse(q3 == \"Very Inaccurate\", 1,\n                ifelse(q3 == \"Moderately Inaccurate\", 2, \n                       ifelse( q3 == \"Neither Accurate nor Inaccurate\", 3, \n                               ifelse(q3 == \"Moderately Accurate\", 4, \n                                      ifelse(q3 == \"Very Accurate\", 5, NA)))))\n  )\n```\n:::\n\n:::panel\n#### case_when\n\nthe final entry here `TRUE ~ NA_real_` is a bit like saying \"and if it is anything else, make it an NA\". \n- note we need to specify the _type_ of NA - i.e. because we are making all of the entries numbers, it needs to be NA_real_. If were were making them characters, it would need to be NA_character\n```{r}\nsurvdat %>% \n  mutate(\n    q3 = case_when(\n      q3 == \"Very Inaccurate\" ~ 1,\n      q3 == \"Moderately Inaccurate\" ~ 2,\n      q3 == \"Neither Accurate nor Inaccurate\" ~ 3,\n      q3 == \"Moderately Accurate\" ~ 4,\n      q3 == \"Very Accurate\" ~ 5,\n      TRUE ~ NA_real_\n    )\n  )\n```\n:::\n\n\n::::\n\n## reverse coding\n\ntidyverse\nbase\n\n\n\n# applying the same operation across variables\n\ntidyverse\nmutate(across())\nbase\napply(df,2,fun)\n\ncheck!\n\n\n\n\n# rowwise metrics\n\ncounting NAs\n\n\n# row scoring\n\nrowsums rowmeans\nNAs\n\nlink reliability\n\n\n\n","srcMarkdownNoYaml":"\n\n```{r}\n#| label: setup\n#| include: false\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nlibrary(tidyverse)\nlibrary(patchwork)\nxaringanExtra::use_panelset()\n```\n\nQuestionnaire data often comes to us in 'wide' format, which is often how we want it for many of the analytical methods we use with questionnaire data. However, working with data in the wide format comes with some specific challenges that generally arise because we have lots and lots of variables. \n\nBelow we will walk through some of the common ways we want to wrangle and clean questionnaire data.  \n\n\n# column names\n\nVery often, the data might come to us with huge long names that correspond to the question being asked.  \nFor instance: \n```{r}\nsurvdat <- read_csv(\"data/surveywrangle.csv\") |> mutate(ppt = 1:n())\nsurvdat <- survdat[,c(60,3:52)]\nnames(survdat) <- gsub(\"Describe yourself as you generally are now, not as you wish to be in the future. Describe yourself as you honestly see yourself, in relation to other people you know of the same age and sex as you are. Remember that responses are anonymised. Please indicate the accuracy for each statement in how it describes you.  \",\"\",names(survdat))\nhead(survdat)\n```\n\nOften, we want our variables to have some easier names to work with, e.g. \"q1\", \"q2\" etc.  \n\nBecause it's often important to keep track of what each question actually asks, it can be useful to create a little dictionary to map our new variable names to the current names.  \n\nIn our data, we have a variable called `ppt`, and then 50 variables corresponding to 50 different questions.  \nWhat I plan to do is rename them to `ppt`, `q1`, `q2`, ..., `q50`.  \n```{r}\ndatadict <- \n  tibble(\n    # these are my proposed new names\n    variable = c(\"ppt\", paste0(\"q\", 1:50)),\n    # current names\n    question = names(survdat)\n  )\nhead(datadict)\n```\n\nIf we want to, we can write this to a .csv file so that we can keep it somewhere useful.\n```{r}\n#| eval: false\nwrite_csv(datadict, file = \"survey_dictionary.csv\")\n```\n\nNow we have created our record, we can actually change the names of the variables:  \n```{r}\nnames(survdat) <- c(\"ppt\", paste0(\"q\", 1:50))\nhead(survdat)\n```\n\n# replacing values and recoding\n\nFirst things first, all of the questions are scored on a 5 point likert^[Technically this is pronounced \"LICK-URT\" and not \"LIE-KURT\". It's named after [Dr Rensis Likert](https://en.wikipedia.org/wiki/Rensis_Likert){target=\"_blank\"}, and that's how he pronounced his name!] scale. \n\nThe data has come out of whatever questionnaire software we used and it's showing the chosen response for each question in words, e.g. \"`r survdat$q1[6]`. But we are going to to treat them as numbers. \nYou might be shouting here that it looks like we're about to turn a set of ordered categories into some interval scale, and that \n\nsome statisticians might maintain that ordinal data is simply __not__ continuous, so we should never treat it as such. In psychology, much research using SEM centers around questionnaire data, which lends itself to *likert* data (for instance, \"strongly agree\",\"agree\",\"neither agree nor disagree\",\"disagree\",\"strongly disagree\"). An often used rule of thumb, is that likert data with $\\geq 5$ levels can be treated as if they are continuous without unduly influencing results (see [Johnson, D.R., & Creech, J.C. (1983). Ordinal measures in multiple indicator models: A simulation study of categorization error](https://discovered.ed.ac.uk/permalink/f/1s15qcp/TN_cdi_crossref_primary_10_2307_2095231)).  \n\n```{r}\n#| echo: false\ntibble(\nresponse = c(\"Very Inaccurate\",\"Moderately Inaccurate\",\"Neither Accurate nor Inaccurate\",\"Moderately Accurate\",\"Very Accurate\"),\nscore = c(1:5)\n) %>% gt::gt()\n```\n\nlet's see how we can do it for one question first: \nthe `recode()` function can be very useful, but there are lots of other approaches\n\n\n\n::::panelset\n:::panel\n#### recode\n\n\n```{r}\nsurvdat %>% \n  mutate(\n    q3 = recode(q3, \n                \"Very Inaccurate\" = 1,\n                \"Moderately Inaccurate\" = 2,\n                \"Neither Accurate nor Inaccurate\" = 3,\n                \"Moderately Accurate\" = 4,\n                \"Very Accurate\" = 5)\n  )\n```\n:::\n:::panel\n#### ifelse\nmuch more cumbersome as it requires multiple nested ifelse statements:\nalso, to ensure that anyhing that isn't one of the 5 valid response options gets to be an NA, we have the final \"else\" specifying that if it's none of the prespecified options, make it an NA\n```{r}\nsurvdat %>% \n  mutate(\n    q3 = ifelse(q3 == \"Very Inaccurate\", 1,\n                ifelse(q3 == \"Moderately Inaccurate\", 2, \n                       ifelse( q3 == \"Neither Accurate nor Inaccurate\", 3, \n                               ifelse(q3 == \"Moderately Accurate\", 4, \n                                      ifelse(q3 == \"Very Accurate\", 5, NA)))))\n  )\n```\n:::\n\n:::panel\n#### case_when\n\nthe final entry here `TRUE ~ NA_real_` is a bit like saying \"and if it is anything else, make it an NA\". \n- note we need to specify the _type_ of NA - i.e. because we are making all of the entries numbers, it needs to be NA_real_. If were were making them characters, it would need to be NA_character\n```{r}\nsurvdat %>% \n  mutate(\n    q3 = case_when(\n      q3 == \"Very Inaccurate\" ~ 1,\n      q3 == \"Moderately Inaccurate\" ~ 2,\n      q3 == \"Neither Accurate nor Inaccurate\" ~ 3,\n      q3 == \"Moderately Accurate\" ~ 4,\n      q3 == \"Very Accurate\" ~ 5,\n      TRUE ~ NA_real_\n    )\n  )\n```\n:::\n\n\n::::\n\n## reverse coding\n\ntidyverse\nbase\n\n\n\n# applying the same operation across variables\n\ntidyverse\nmutate(across())\nbase\napply(df,2,fun)\n\ncheck!\n\n\n\n\n# rowwise metrics\n\ncounting NAs\n\n\n# row scoring\n\nrowsums rowmeans\nNAs\n\nlink reliability\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"include-in-header":["assets/toggling.html"],"number-sections":false,"output-file":"surveywrangle.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","toc_float":true,"link-citations":true,"theme":["united","assets/style-labs.scss"],"title":"Data wrangling for surveys & questionnaires","author":"hello","params":{"SHOW_SOLS":true,"TOGGLE":true},"editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}