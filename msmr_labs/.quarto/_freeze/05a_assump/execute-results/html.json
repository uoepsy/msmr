{
  "hash": "dae00a881eb6639d7f6c0cd1a4046134",
  "result": {
    "markdown": "---\ntitle: \"5A: Model Assumptions\"\nparams: \n    SHOW_SOLS: FALSE\n    TOGGLE: TRUE\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n\n:::lo\nThis reading:  \n\n- Multilevel model assumptions: random effects can be thought of as another level of residual!  \n\n- Influence in multilevel models: influential observations and influential groups.\n\n:::\n\n# MLM Assumptions & Diagnostics\n\nHopefully by now you are getting comfortable with the idea that all our models are simplifications, and so there is always going to be some difference between a model and real-life. This difference - the _residual_ - will ideally just be randomness, and we assess this by checking for systematic patterns in the residual term.  \n\nNot much is different in the multilevel model - we simply now have \"residuals\" on multiple levels. We are assuming that our group-level differences represent one level of randomness, and that our observations represent another level. We can see these two levels in @fig-lmmres, with the group-level deviations from the fixed effects ($\\color{orange}{\\zeta_{0i}}$ and $\\color{orange}{\\zeta_{1i}}$) along with the observation-level deviations from that groups line ($\\varepsilon_{ij}$).  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Multilevel model with group $i$ highlighted](images/un_lmm2.png){#fig-lmmres fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n\nLet's suppose we are studying employee job satisfaction at the university. We have 399 employees from 25 different departments, and we got them to fill in a job satisfaction questionnaire, and got information on what their payscale was. We have also taken information from the national student survey on the level of student satisfaction for each department.  \n\nEach datapoint here represents an individual employee, and these employees are grouped into departments.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lme4)\njsuni <- read_csv(\"https://uoepsy.github.io/data/msmr_nssjobsat.csv\")\nhead(jsuni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  NSSrating dept                                   payscale jobsat jobsat_binary\n      <dbl> <chr>                                     <dbl>  <dbl>         <dbl>\n1       4.8 International Public Health Policy            6     19             1\n2       6.7 Language Sciences                             8     17             0\n3       6.9 BSc Hons (Royal (Dick) Sch of Veterin…        7     17             0\n4       6.3 Veterinary Sciences                           7     16             0\n5       4.8 African Studies                               9     18             0\n6       4   Electronics                                   7     18             0\n```\n:::\n:::\n\n\nWe had a model that included by-participant random effects, such as:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njsmod <- lmer(jobsat ~ 1 + payscale + NSSrating + \n                (1 + payscale| dept), \n              data = jsuni)\n```\n:::\n\n\nThe equation for such a model would take the following form:  \n$$\n\\begin{align}\n\\text{For Employee }j\\text{ from Department }i& \\\\\n\\text{Level 1 (Employee):}& \\\\\n\\text{Stress}_{ij} &= b_{0i} + b_{1i} \\cdot \\text{Payscale}_{ij} + \\epsilon_{ij} \\\\\n\\text{Level 2 (Department):}& \\\\\nb_{0i} &= \\gamma_{00} + \\zeta_{0i} + \\gamma_{01} \\cdot \\text{NSSrating}_i\\\\\nb_{1i} &= \\gamma_{10} + \\zeta_{1i} \\\\\n& \\qquad \\\\\n\\text{Where:}& \\\\\n& \\begin{bmatrix} \\zeta_{0i} \\\\ \\zeta_{1i} \\end{bmatrix}\n\\sim N\n\\left(\n    \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix},\n    \\begin{bmatrix}\n        \\sigma_0 & \\rho \\sigma_0 \\sigma_1 \\\\\n        \\rho \\sigma_0 \\sigma_1 & \\sigma_1\n    \\end{bmatrix}\n\\right) \\\\\n& \\qquad \\\\\n& \\varepsilon_{ij} \\sim N(0,\\sigma_\\varepsilon)\n\\end{align}\n$$\n\nNote that this equation makes clear the distributional assumptions that our models make. It states the residuals $\\varepsilon$ are normally distributed with a mean of zero, and it says the same thing about our random effects!  \n\n\n## Level 1 residuals\n\nWe can get the level 1 (observation-level) residuals the same way we used to do for `lm()` - by just using `resid()` or `residuals()`.   Additionally, there are a few useful techniques for plotting these which we have listed below:  \n\n::::panelset\n:::panel\n#### resid vs fitted\n\nWe can plot the residuals vs fitted model (just like we used to for `lm()`), and assess the extend to which the assumption holds that the residuals are zero mean. \n_(we want the blue smoothed line to be fairly close to zero across the plot)_  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# \"p\" below is for points and \"smooth\" for the smoothed line\nplot(jsmod, type=c(\"p\",\"smooth\"))\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n:::panel\n#### scale-location\n\nAgain, like we can for `lm()`, we can also look at a scale-location plot. This is where the square-root of the absolute value of the residuals is plotted against the fitted values, and allows us to more easily assess the assumption of constant variance.  \n_(we want the blue smoothed line to be close to horizontal across the plot)_  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(jsmod,\n     form = sqrt(abs(resid(.))) ~ fitted(.),\n     type = c(\"p\",\"smooth\"))\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n:::panel\n#### facetted plots\n\nWe can also plot these \"resid v fitted\" and \"scale-location\" plots for each cluster, to check that our residual mean and variance is not related to the clusters:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(jsmod,\n         form = resid(.) ~ fitted(.) | dept,\n         type = c(\"p\"))\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(jsmod,\n         form = sqrt(abs(resid(.))) ~ fitted(.) | dept,\n         type = c(\"p\"))\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=80%}\n:::\n:::\n\n    \n:::\n:::panel\n#### residual normality\n    \nWe can also examine the normality the level 1 residuals, using things such as histograms and QQplots:    \n_(we want the datapoints to follow close to the diagonal line)_  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqqnorm(resid(jsmod)); qqline(resid(jsmod))\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhist(resid(jsmod))\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n:::\n::::\n\n## Level 2+ residuals\n\nThe second level of residuals in the multilevel model are actually just our random effects! We've seen them already whenever we use `ranef()`!  \n\nTo get out these we often need to do a bit of indexing. `ranef(model)` will give us a list with an item for each grouping. In each item we have a set of columns, one for each thing which is varying by that grouping.  \n\nBelow, we see that `ranef(jsmod)` gives us something with one entry, `$dept`, which contains 2 columns (the random intercepts and random slopes of `payscale`):  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nranef(jsmod)\n```\n:::\n\n```\n$dept\n                                        (Intercept)    payscale\nAccounting                              -0.03045458 -0.19259376\nArchitecture and Landscape Architecture  0.29419381 -0.35855884\nArt                                     -0.29094345  0.15293285\nBusiness Studies                        -0.27858102  0.18008149\n...                                      ...         ... \n```\n\nSo we can extract the random intercepts using `ranef(jsmod)$dept[,1]`.  \n\nAgain, we want normality of the random effects, so we can make more histograms or qqplots, for both the random intercepts and the random slopes:  \n\ne.g., for the random intercepts:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqqnorm(ranef(jsmod)$dept[,1]);qqline(ranef(jsmod)$dept[,1])\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nand for the random slopes:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqqnorm(ranef(jsmod)$dept[,2]);qqline(ranef(jsmod)$dept[,2])\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n## model simulations\n\nSometimes, a good global assessment of your model comes from how good a representation of the observed data it is. We can look at this in a cool way by simulating from our model a new set of values for the outcome. If we do this a few times over, and plot each 'draw' (i.e. set of simulated values), we can look at how well it maps to the observed set of values:  \n\nOne quick way to do this is with the `check_predictions()` function from the __performance__ package:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(performance)\ncheck_predictions(jsmod, iterations = 200)\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n#### optional: doing it yourself\n\nDoing this ourself gives us a lot more scope to query differences between our observed vs model-predicted data.  \n\nThe `simulate()` function will simulate response variable values for us.  \nThe `re.form = NULL` bit is saying to include the random effects when making simulations (i.e. use the information about the specific clusters we _have_ in our data). If we said `re.form = NA` it would base simulations on a randomly generated set of clusters with the associated intercept and slope variances estimated by our model.  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodsim <- simulate(jsmod, nsim = 200, re.form=NULL)\n```\n:::\n\nTo get this plotted, we'll have to do a bit of reworking, because it gives us a separate column for each draw. So if we pivot them longer we can make a density plot for each draw, and then add on top of that our observed scores:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# take the simulations\nmodsim |> \n  # pivot \"everything()\" (useful function to capture all columns),\n  # put column names into \"sim\", and the values into \"value\"\n  pivot_longer(everything(), names_to=\"sim\",values_to=\"value\") |>\n  # plot them! \n  ggplot(aes(x=value))+\n  # plot a different line for each sim. \n  # to make the alpha transparency work, i need to use\n  # geom_line(stat=\"density\") rather than \n  # geom_density() (for some reason alpha applies to fill here)\n  geom_line(aes(group=sim), stat=\"density\", alpha=.1,\n            col=\"darkorange\") +\n  # finally, add the observed scores!  \n  geom_density(data = jsuni, aes(x=jobsat), lwd=1)\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nHowever, we can also go further! We can pick a statistic, let's use the IQR, and see how different our observed IQR is from the IQRs of a series of simulated draws.  \n\nHere are 1000 simulations. This time I don't care about simulating for these specific clusters, I just want to compare to random draws of clusters:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsims <- simulate(jsmod, nsim=1000, re.form=NA)\n```\n:::\n\n\nThe `apply()` function (see also `lapply`, `sapply` ,`vapply`, `tapply`) is a really nice way to take an object, and apply a function to it. \nThe number 2 here is to say \"do it on each column\". If we had 1 it would be saying \"do it on each row\".  \nThis gives us the IQR of each simulation:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsimsIQR <- apply(sims, 2, IQR)\n```\n:::\n\n\nWe can then ask what proportion of our simulated draws have an IQR smaller than our observed IQR? If the answer is very big or very small it indicates our model does not very represent this part of reality very well.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(IQR(jsuni$jobsat)>simsIQR)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.451\n```\n:::\n:::\n\n\n:::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Influence\n\nJust like individual observations can exert influence on a single level linear model fitted with `lm()`, they can influence our multilevel models too. Just like our assumptions now apply at multiple levels, influence can happen at multiple levels too.  \n\nAn individual observation might influence our model (as in @fig-infl1), but so might an entire cluster (@fig-infl2).  \n\n:::: {.columns}\n:::{.column width=\"47.5%\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Dashed lines show fixed effects from (black line) model with the highlighted red observation, and (red line) model without the highlighted red observation.](05a_assump_files/figure-html/fig-infl1-1.png){#fig-infl1 fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n:::{.column width=\"5%\"}\n:::\n:::{.column width=\"47.5%\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Dashed lines show fixed effects from (black line) model with the highlighted group, and (red line) model without the highlighted group.](05a_assump_files/figure-html/fig-infl2-1.png){#fig-infl2 fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n::::\n\nThere are two main packages for examining influence in multilevel models, __HLMdiag__ and __influence.ME__ that work by going through and deleting each observation/cluster and examining how much things change. __HLMdiag__ works for `lmer()` but not `glmer()`, but provides a one-step approximation of the influence, which is often quicker than the full refitting process. The __influence.ME__ package will be slower, but works for both `lmer()` and `glmer()`.    \n\n::::panelset\n:::panel\n#### HLMdiag\n\nWe use this package by creating an object using `hlm_influence()`, specifying the level at which we want to examine influence.  \nIn this case, `level = 1` means we are looking at the influence of individual observations, and `level = \"dept\"` specifies that we are looking at the influence of the levels in the `dept` variable.  \nThe `approx = TRUE` part means that we are asking for the approximate calculations of influence measures, rather than asking for it to actually iteratively delete each observation and re-fit the model.  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(HLMdiag)\ninf1 <- hlm_influence(model = jsmod, level = 1, approx = TRUE)\ninf2 <- hlm_influence(model = jsmod, level = \"dept\", approx = TRUE)\n```\n:::\n\n\nWe can then plot metrics such as the cooks distance for each of these. Note that the \"internal\" cutoff here adds a red line to the plots, and is simply calculated as the 3rd quartile plus 3 times the IQR, thereby capturing a relative measure of outlyingness.  \nAs with the measures of influence for `lm()`, such cutoffs are somewhat arbitrary, and so should be interpreted with caution.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndotplot_diag(inf1$cooksd, cutoff = \"internal\")\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-24-1.png){fig-align='center' width=80%}\n:::\n\n```{.r .cell-code}\ndotplot_diag(inf2$cooksd, \n             index = inf2$dept, cutoff = \"internal\")\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-24-2.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n:::\n:::panel\n#### influence.ME\n\nWe use this package by creating an object using `influence()`, specifying the level at which we want to examine influence.  \nIn this case, `obs = TRUE` means we are looking at the influence of individual observations, and `group = \"dept\"` specifies that we are looking at the influence of the levels in the `dept` variable.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(influence.ME)\ninf1 <- influence(model = jsmod, obs = TRUE)\ninf2 <- influence(model = jsmod, group = \"dept\")\n```\n:::\n\n\nWe can then plot metrics such as the cooks distance for each of these:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(inf1, which = \"cook\", sort=TRUE)\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-26-1.png){fig-align='center' width=80%}\n:::\n\n```{.r .cell-code}\nplot(inf2, which = \"cook\", sort=TRUE)\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-26-2.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n::::\n\nTo conduct a sensitivity analysis of our models robustness to the inclusion of such influential observations, we would simply fit our model with and without that observation/cluster, and examine if/how our conclusions would change.  \nFor instance, to refit our model without employees of the 'Nursing Studies' department: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njsmod_NS <- lmer(jobsat ~ 1 + payscale + NSSrating + \n                (1 + payscale| dept), \n              data = jsuni |> \n                filter(dept!=\"Nursing Studies\"))\n```\n:::\n\nThe `tidy()` function from __broom.mixed__ is a quick way to print out parameters from each model:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntidy(jsmod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 6\n  effect   group    term                      estimate std.error statistic\n  <chr>    <chr>    <chr>                        <dbl>     <dbl>     <dbl>\n1 fixed    <NA>     (Intercept)                 14.5      0.998      14.6 \n2 fixed    <NA>     payscale                     0.336    0.0800      4.21\n3 fixed    <NA>     NSSrating                    0.428    0.132       3.25\n4 ran_pars dept     sd__(Intercept)              0.934   NA          NA   \n5 ran_pars dept     cor__(Intercept).payscale   -0.494   NA          NA   \n6 ran_pars dept     sd__payscale                 0.294   NA          NA   \n7 ran_pars Residual sd__Observation              1.02    NA          NA   \n```\n:::\n\n```{.r .cell-code}\ntidy(jsmod_NS)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 6\n  effect   group    term                      estimate std.error statistic\n  <chr>    <chr>    <chr>                        <dbl>     <dbl>     <dbl>\n1 fixed    <NA>     (Intercept)                 15.4      0.999      15.5 \n2 fixed    <NA>     payscale                     0.324    0.0806      4.02\n3 fixed    <NA>     NSSrating                    0.318    0.132       2.42\n4 ran_pars dept     sd__(Intercept)              0.516   NA          NA   \n5 ran_pars dept     cor__(Intercept).payscale   -0.594   NA          NA   \n6 ran_pars dept     sd__payscale                 0.292   NA          NA   \n7 ran_pars Residual sd__Observation              1.02    NA          NA   \n```\n:::\n:::\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Optional Extra: The DHARMa Package\n\n__DHARMa__ is a cool package that attempts to construct easy to interpret residuals for models of various families (allowing us to construct useful plots to look at for binomial and poisson models fitted with `glmer()`). \n\nIt achieves this by doing lots of simulated draws from the model, and for each observation $i$ it asks where the actual value falls in relation to the simulated values for that observation (i.e. that combination of predictors). If the observed is exactly what we would expect, it would fall right in the middle taking a value of 0.5 (0.5 of the simulated distribution for observation $i$ will be below and 0.5 will be below). If all the simulated values fall below the observed value, it would take the value 1. The DHARMa package has a good explanation of how this works in more detail ([https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html](https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html){target=\"_blank\"}), but it can be done for `lmer()`, `glmer()` and more.  \n\nHere's a binomial logistic model, where instead of a job-satisfaction _score_, we have a simple yes/no for job satisfaction:   \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njsmod2 <- glmer(jobsat_binary ~ 1 + payscale + NSSrating + \n                  (1 + payscale | dept), \n                data = jsuni, family=binomial)\n```\n:::\n\n\nThe DHARMa package works by first getting the simulated residuals\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(DHARMa)\nmsim <- simulateResiduals(fittedModel = jsmod2)\n```\n:::\n\n\nIf our model is correctly specified, then the DHARMa residuals we would expect to be uniform (i.e. flat), and also uniform distributed across any predictor.  \n\nIt offers some nice ways to assess this, by plotting the observed vs expected distribution on a QQplot:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplotQQunif(msim)\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-31-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nAnd it plots the residuals against the fitted, while adding lines for quantiles of the distribution. If the middle one is flat, it equates to the \"zero mean\" assumption, and if the outer two are flat it equates to our \"constant variance\" assumption.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplotResiduals(msim)\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-32-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nWe can also plot the residuals against specific predictors:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplotResiduals(msim, form = jsuni$NSSrating)\n```\n\n::: {.cell-output-display}\n![](05a_assump_files/figure-html/unnamed-chunk-33-1.png){fig-align='center' width=80%}\n:::\n:::\n",
    "supporting": [
      "05a_assump_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/panelset-0.3.0/panelset.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/panelset-0.3.0/panelset.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}