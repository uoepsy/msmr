{
  "hash": "e04d06aaa7e76a2637b24e98369a94ae",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Questionnaire Data Wrangling\"\nparams: \n    SHOW_SOLS: TRUE\n    TOGGLE: TRUE\neditor_options: \n  chunk_output_type: inline\n---\n\n\n\n\n\n\nQuestionnaire data often comes to us in 'wide' format, which is often how we want it for many of the analytical methods we use with questionnaire data. However, working with data in the wide format comes with some specific challenges that generally arise because we have lots and lots of variables. \n\nBelow we will walk through some of the common ways we want to wrangle and clean questionnaire data.  \n\n\n# Variable names\n\nVery often, the data might come to us with huge long names that correspond to the question being asked.  \nFor instance: \n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat <- read_csv(\"https://uoepsy.github.io/data/surveywrangle.csv\")\nhead(survdat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 53\n    ppt   age height `[I am the life of the party.]` [I feel little concern fo…¹\n  <dbl> <dbl>  <dbl> <chr>                           <chr>                      \n1     1    22    168 Moderately Accurate             Very Inaccurate            \n2     2    29    186 Neither Accurate nor Inaccurate Moderately Inaccurate      \n3     3    24     NA Very Inaccurate                 Very Inaccurate            \n4     4    26    175 Very Inaccurate                 Moderately Inaccurate      \n5     5    28    182 Very Inaccurate                 Very Inaccurate            \n6     6    27    159 Moderately Accurate             Very Inaccurate            \n# ℹ abbreviated name: ¹​`[I feel little concern for others.]`\n# ℹ 48 more variables: `[I am always prepared.]` <chr>,\n#   `[I get stressed out easily.]` <chr>, `[I have a rich vocabulary.]` <chr>,\n#   `[I don't talk a lot.]` <chr>, `[I am interested in people.]` <chr>,\n#   `[I leave my belongings around.]` <chr>,\n#   `[I am relaxed most of the time.]` <chr>,\n#   `[I have difficulty understanding abstract ideas.]` <chr>, …\n```\n\n\n:::\n:::\n\n\n\n\n\nOften, we want our variables to have some easier names to work with, e.g. \"q1\", \"q2\" etc.  \n\nBecause it's often important to keep track of what each question actually asks, it can be useful to create a little dictionary to map our new variable names to the current names.  \n\nIn our data, we have variables called `ppt`, `age` and `height`, and then 50 variables corresponding to 50 different questions.  \nWhat I plan to do is rename them to `ppt`,`age`,`height`,`q1`, `q2`, ..., `q50`.  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### what do `paste()/paste0()` do?   \n\nThe `paste` functions allow us to simply \"paste\" characters together:  \nBy default, `paste()` will separate these with a space:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npaste(\"i have a dog called\", \"dougal\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"i have a dog called dougal\"\n```\n\n\n:::\n:::\n\n\n\nand `paste0()` will not separate them by anything:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npaste0(\"i have a dog called\", \"dougal\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"i have a dog calleddougal\"\n```\n\n\n:::\n:::\n\n\n\n\nWe can paste the same thing to a set of things: \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npaste(\"i have a dog called\", c(\"dougal\", \"rufus\",\"rosie\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"i have a dog called dougal\" \"i have a dog called rufus\" \n[3] \"i have a dog called rosie\" \n```\n\n\n:::\n:::\n\n\n\nWhich can be useful for quickly making a set of variable names: \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npaste0(\"item_\",1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"item_1\"  \"item_2\"  \"item_3\"  \"item_4\"  \"item_5\"  \"item_6\"  \"item_7\" \n [8] \"item_8\"  \"item_9\"  \"item_10\"\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndatadict <- \n  tibble(\n    # these are my proposed new names\n    variable = c(\"ppt\",\"age\",\"height\", \n                 paste0(\"q\", 1:50)),\n    # current names\n    question = names(survdat)\n  )\nhead(datadict)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  variable question                           \n  <chr>    <chr>                              \n1 ppt      ppt                                \n2 age      age                                \n3 height   height                             \n4 q1       [I am the life of the party.]      \n5 q2       [I feel little concern for others.]\n6 q3       [I am always prepared.]            \n```\n\n\n:::\n:::\n\n\n\n\nIf we want to, we can write this to a .csv file so that we can keep it somewhere useful.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwrite_csv(datadict, file = \"survey_dictionary.csv\")\n```\n:::\n\n\n\n\nNow we have created our record, we can actually change the names of the variables:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnames(survdat)[4:53] <- paste0(\"q\", 1:50)\nhead(survdat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 53\n    ppt   age height q1    q2    q3    q4    q5    q6    q7    q8    q9    q10  \n  <dbl> <dbl>  <dbl> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr>\n1     1    22    168 Mode… Very… Mode… Mode… Neit… Mode… Mode… Mode… Mode… Neit…\n2     2    29    186 Neit… Mode… Mode… Neit… Mode… Mode… Mode… Mode… Neit… Neit…\n3     3    24     NA Very… Very… Neit… Mode… Mode… Mode… Mode… Neit… Mode… Very…\n4     4    26    175 Very… Mode… Mode… Mode… Very… Mode… Mode… Mode… Mode… Mode…\n5     5    28    182 Very… Very… Neit… Mode… Mode… Very… Neit… Neit… Mode… Mode…\n6     6    27    159 Mode… Very… Mode… Very… Very… Neit… Mode… Very… Neit… Mode…\n# ℹ 40 more variables: q11 <chr>, q12 <chr>, q13 <chr>, q14 <chr>, q15 <chr>,\n#   q16 <chr>, q17 <chr>, q18 <chr>, q19 <chr>, q20 <chr>, q21 <chr>,\n#   q22 <chr>, q23 <chr>, q24 <chr>, q25 <chr>, q26 <chr>, q27 <chr>,\n#   q28 <chr>, q29 <chr>, q30 <chr>, q31 <chr>, q32 <chr>, q33 <chr>,\n#   q34 <chr>, q35 <chr>, q36 <chr>, q37 <chr>, q38 <chr>, q39 <chr>,\n#   q40 <chr>, q41 <chr>, q42 <chr>, q43 <chr>, q44 <chr>, q45 <chr>,\n#   q46 <chr>, q47 <chr>, q48 <chr>, q49 <chr>, q50 <chr>\n```\n\n\n:::\n:::\n\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Variable recoding\n\nFirst things first, all of the questions are scored on a 5 point likert^[Technically this is pronounced \"LICK-URT\" and not \"LIE-KURT\". It's named after [Dr Rensis Likert](https://en.wikipedia.org/wiki/Rensis_Likert){target=\"_blank\"}, and that's how he pronounced his name!] scale. \n\nThe data has come out of whatever questionnaire software we used and it's showing the chosen response for each question in words, e.g. \"Moderately Accurate\". But we are going to turn them into numbers so that they are easier to work with.  \n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"gnschrclth\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#gnschrclth table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#gnschrclth thead, #gnschrclth tbody, #gnschrclth tfoot, #gnschrclth tr, #gnschrclth td, #gnschrclth th {\n  border-style: none;\n}\n\n#gnschrclth p {\n  margin: 0;\n  padding: 0;\n}\n\n#gnschrclth .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#gnschrclth .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#gnschrclth .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#gnschrclth .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#gnschrclth .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#gnschrclth .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#gnschrclth .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#gnschrclth .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#gnschrclth .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#gnschrclth .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#gnschrclth .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#gnschrclth .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#gnschrclth .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#gnschrclth .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#gnschrclth .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#gnschrclth .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#gnschrclth .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#gnschrclth .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#gnschrclth .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#gnschrclth .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#gnschrclth .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#gnschrclth .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#gnschrclth .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#gnschrclth .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#gnschrclth .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#gnschrclth .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#gnschrclth .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#gnschrclth .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#gnschrclth .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#gnschrclth .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#gnschrclth .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#gnschrclth .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#gnschrclth .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#gnschrclth .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#gnschrclth .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#gnschrclth .gt_left {\n  text-align: left;\n}\n\n#gnschrclth .gt_center {\n  text-align: center;\n}\n\n#gnschrclth .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#gnschrclth .gt_font_normal {\n  font-weight: normal;\n}\n\n#gnschrclth .gt_font_bold {\n  font-weight: bold;\n}\n\n#gnschrclth .gt_font_italic {\n  font-style: italic;\n}\n\n#gnschrclth .gt_super {\n  font-size: 65%;\n}\n\n#gnschrclth .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#gnschrclth .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#gnschrclth .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#gnschrclth .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#gnschrclth .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#gnschrclth .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#gnschrclth .gt_indent_5 {\n  text-indent: 25px;\n}\n\n#gnschrclth .katex-display {\n  display: inline-flex !important;\n  margin-bottom: 0.75em !important;\n}\n\n#gnschrclth div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after {\n  height: 0px !important;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"response\">response</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"score\">score</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"response\" class=\"gt_row gt_left\">Very Inaccurate</td>\n<td headers=\"score\" class=\"gt_row gt_right\">1</td></tr>\n    <tr><td headers=\"response\" class=\"gt_row gt_left\">Moderately Inaccurate</td>\n<td headers=\"score\" class=\"gt_row gt_right\">2</td></tr>\n    <tr><td headers=\"response\" class=\"gt_row gt_left\">Neither Accurate nor Inaccurate</td>\n<td headers=\"score\" class=\"gt_row gt_right\">3</td></tr>\n    <tr><td headers=\"response\" class=\"gt_row gt_left\">Moderately Accurate</td>\n<td headers=\"score\" class=\"gt_row gt_right\">4</td></tr>\n    <tr><td headers=\"response\" class=\"gt_row gt_left\">Very Accurate</td>\n<td headers=\"score\" class=\"gt_row gt_right\">5</td></tr>\n  </tbody>\n  \n  \n</table>\n</div>\n```\n\n:::\n:::\n\n\n\n\nYou might be shouting at the screen here that by turning these words into numbers we're about to turn a set of ordered categories into an interval scale. Is \"Moderately Inaccurate\" really 2 x \"Very Inaccurate\"? You might be right to have this intuition - it's a contentious issue! In psychology, in which questionnaire based methods are everywhere, an often used rule of thumb is that likert data with $\\geq 5$ levels can be treated as if they are continuous without unduly influencing results (see [Johnson, D.R., & Creech, J.C. (1983). Ordinal measures in multiple indicator models: A simulation study of categorization error](https://discovered.ed.ac.uk/permalink/f/1s15qcp/TN_cdi_crossref_primary_10_2307_2095231){target=\"_blank\"}).  \n\nLet's push on and see how we can do this sort of recoding.  \nFirst we'll do it for just one variable. As always in R, there are lots of ways to do the same thing. All of these approaches follows an if-else type logic - \"if we have 'moderately inaccurate', make it '2', and if we have 'very inaccurate, make it 1, and if ... \".  \n\n\n::::panelset\n:::panel\n#### ifelse()  \n\nThis is the most cumbersome way to do this logic as it requires multiple nested ifelse statements.  \nTo ensure that anything that isn't one of the 5 valid response options gets to be an NA, we have the final \"else\" specifying that if it's none of the prespecified options, make it an NA\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |>\n  mutate(\n    q1 = ifelse(q1 == \"Very Inaccurate\", 1,\n                ifelse(q1 == \"Moderately Inaccurate\", 2, \n                       ifelse( q1 == \"Neither Accurate nor Inaccurate\", 3, \n                               ifelse(q1 == \"Moderately Accurate\", 4, \n                                      ifelse(q1 == \"Very Accurate\", 5, NA)))))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 53\n     ppt   age height    q1 q2         q3    q4    q5    q6    q7    q8    q9   \n   <dbl> <dbl>  <dbl> <dbl> <chr>      <chr> <chr> <chr> <chr> <chr> <chr> <chr>\n 1     1    22    168     4 Very Inac… Mode… Mode… Neit… Mode… Mode… Mode… Mode…\n 2     2    29    186     3 Moderatel… Mode… Neit… Mode… Mode… Mode… Mode… Neit…\n 3     3    24     NA     1 Very Inac… Neit… Mode… Mode… Mode… Mode… Neit… Mode…\n 4     4    26    175     1 Moderatel… Mode… Mode… Very… Mode… Mode… Mode… Mode…\n 5     5    28    182     1 Very Inac… Neit… Mode… Mode… Very… Neit… Neit… Mode…\n 6     6    27    159     4 Very Inac… Mode… Very… Very… Neit… Mode… Very… Neit…\n 7     7    27    149     2 Very Inac… Mode… Very… Mode… Mode… Mode… Mode… Neit…\n 8     8    23    178     2 Neither A… Very… Very… Neit… Neit… Mode… Very… Very…\n 9     9    28    176     3 Moderatel… Very… Very… Very… Neit… Very… Neit… Neit…\n10    10    26    192     3 Very Inac… Mode… Mode… Mode… Neit… Mode… Mode… Mode…\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <chr>, q11 <chr>, q12 <chr>, q13 <chr>, q14 <chr>,\n#   q15 <chr>, q16 <chr>, q17 <chr>, q18 <chr>, q19 <chr>, q20 <chr>,\n#   q21 <chr>, q22 <chr>, q23 <chr>, q24 <chr>, q25 <chr>, q26 <chr>,\n#   q27 <chr>, q28 <chr>, q29 <chr>, q30 <chr>, q31 <chr>, q32 <chr>,\n#   q33 <chr>, q34 <chr>, q35 <chr>, q36 <chr>, q37 <chr>, q38 <chr>,\n#   q39 <chr>, q40 <chr>, q41 <chr>, q42 <chr>, q43 <chr>, q44 <chr>, …\n```\n\n\n:::\n:::\n\n\n\n:::\n:::panel\n#### case_when\n\n`case_when()` follows this same logic as `ifelse()` but makes for easier reading (and writing). Each line is a statement saying \"if [variable] is equal to [value], then return [new value]\". The final entry here `TRUE ~ NA` is a bit like saying \"and if it is anything else, make it an NA\". \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |>\n  mutate(\n    q1 = case_when(\n      q1 == \"Very Inaccurate\" ~ 1,\n      q1 == \"Moderately Inaccurate\" ~ 2,\n      q1 == \"Neither Accurate nor Inaccurate\" ~ 3,\n      q1 == \"Moderately Accurate\" ~ 4,\n      q1 == \"Very Accurate\" ~ 5,\n      TRUE ~ NA\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 53\n     ppt   age height    q1 q2         q3    q4    q5    q6    q7    q8    q9   \n   <dbl> <dbl>  <dbl> <dbl> <chr>      <chr> <chr> <chr> <chr> <chr> <chr> <chr>\n 1     1    22    168     4 Very Inac… Mode… Mode… Neit… Mode… Mode… Mode… Mode…\n 2     2    29    186     3 Moderatel… Mode… Neit… Mode… Mode… Mode… Mode… Neit…\n 3     3    24     NA     1 Very Inac… Neit… Mode… Mode… Mode… Mode… Neit… Mode…\n 4     4    26    175     1 Moderatel… Mode… Mode… Very… Mode… Mode… Mode… Mode…\n 5     5    28    182     1 Very Inac… Neit… Mode… Mode… Very… Neit… Neit… Mode…\n 6     6    27    159     4 Very Inac… Mode… Very… Very… Neit… Mode… Very… Neit…\n 7     7    27    149     2 Very Inac… Mode… Very… Mode… Mode… Mode… Mode… Neit…\n 8     8    23    178     2 Neither A… Very… Very… Neit… Neit… Mode… Very… Very…\n 9     9    28    176     3 Moderatel… Very… Very… Very… Neit… Very… Neit… Neit…\n10    10    26    192     3 Very Inac… Mode… Mode… Mode… Neit… Mode… Mode… Mode…\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <chr>, q11 <chr>, q12 <chr>, q13 <chr>, q14 <chr>,\n#   q15 <chr>, q16 <chr>, q17 <chr>, q18 <chr>, q19 <chr>, q20 <chr>,\n#   q21 <chr>, q22 <chr>, q23 <chr>, q24 <chr>, q25 <chr>, q26 <chr>,\n#   q27 <chr>, q28 <chr>, q29 <chr>, q30 <chr>, q31 <chr>, q32 <chr>,\n#   q33 <chr>, q34 <chr>, q35 <chr>, q36 <chr>, q37 <chr>, q38 <chr>,\n#   q39 <chr>, q40 <chr>, q41 <chr>, q42 <chr>, q43 <chr>, q44 <chr>, …\n```\n\n\n:::\n:::\n\n\n\n:::\n:::panel\n#### case_match()\n\nThe `ifelse()` and `case_when()` functions are much more generalised - we can say \"if x is 1 make it 1, and if y is 2 make it 0, and if z is ... \".  \n\nHowever, in the task at hand, all of our \"if\" questions apply to the value of the same variable. The `case_match()` function is perfectly designed for this:  \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  mutate(\n    q1 = case_match(q1, \n                \"Very Inaccurate\" ~ 1,\n                \"Moderately Inaccurate\" ~ 2,\n                \"Neither Accurate nor Inaccurate\" ~ 3,\n                \"Moderately Accurate\" ~ 4,\n                \"Very Accurate\" ~ 5)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 53\n     ppt   age height    q1 q2         q3    q4    q5    q6    q7    q8    q9   \n   <dbl> <dbl>  <dbl> <dbl> <chr>      <chr> <chr> <chr> <chr> <chr> <chr> <chr>\n 1     1    22    168     4 Very Inac… Mode… Mode… Neit… Mode… Mode… Mode… Mode…\n 2     2    29    186     3 Moderatel… Mode… Neit… Mode… Mode… Mode… Mode… Neit…\n 3     3    24     NA     1 Very Inac… Neit… Mode… Mode… Mode… Mode… Neit… Mode…\n 4     4    26    175     1 Moderatel… Mode… Mode… Very… Mode… Mode… Mode… Mode…\n 5     5    28    182     1 Very Inac… Neit… Mode… Mode… Very… Neit… Neit… Mode…\n 6     6    27    159     4 Very Inac… Mode… Very… Very… Neit… Mode… Very… Neit…\n 7     7    27    149     2 Very Inac… Mode… Very… Mode… Mode… Mode… Mode… Neit…\n 8     8    23    178     2 Neither A… Very… Very… Neit… Neit… Mode… Very… Very…\n 9     9    28    176     3 Moderatel… Very… Very… Very… Neit… Very… Neit… Neit…\n10    10    26    192     3 Very Inac… Mode… Mode… Mode… Neit… Mode… Mode… Mode…\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <chr>, q11 <chr>, q12 <chr>, q13 <chr>, q14 <chr>,\n#   q15 <chr>, q16 <chr>, q17 <chr>, q18 <chr>, q19 <chr>, q20 <chr>,\n#   q21 <chr>, q22 <chr>, q23 <chr>, q24 <chr>, q25 <chr>, q26 <chr>,\n#   q27 <chr>, q28 <chr>, q29 <chr>, q30 <chr>, q31 <chr>, q32 <chr>,\n#   q33 <chr>, q34 <chr>, q35 <chr>, q36 <chr>, q37 <chr>, q38 <chr>,\n#   q39 <chr>, q40 <chr>, q41 <chr>, q42 <chr>, q43 <chr>, q44 <chr>, …\n```\n\n\n:::\n:::\n\n\n\n\nIf we wanted to collapse levels, the syntax works like so:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  mutate(\n    q1 = case_match(q1, \n                    c(\"Very Inaccurate\",\"Moderately Inaccurate\") ~ 1,\n                    \"Neither Accurate nor Inaccurate\" ~ 2,\n                    c(\"Moderately Accurate\",\"Very Accurate\") ~ 3\n    )\n  )\n```\n:::\n\n\n\n\n\n:::\n\n::::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Applying the same operation across variables\n\nNow that we know how to recode a variable, what if we want to do it for all 50 questions? We don't want to do it manually, because that would be hugely inefficient:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> mutate(\n  q1 = case_match(q1,\n    ...\n    ..\n    ...\n  ),\n  q2 = case_match(q2,\n    ...\n    ..\n    ...\n  ),\n  ..\n)\n```\n:::\n\n\n\n\nThere are various ways to do this, but the two main ones are by utilising __tidyverse__'s `across()` function, or by using the Base R `apply()` function.  \n\n::::panelset\n:::panel\n#### across()\n\nThe `across()` function works inside other tidyverse functions like `summarise()` and `mutate()`, and allows us to do the same operation across a set of columns.  \n\nThe syntax is (with either summarise or mutate):  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata |>\n  mutate(across(variables, operation))\n```\n:::\n\n\n\n\nAs an example, suppose i wanted to summarise across the first three variables (`ppt`,`age`, and `height`) and get the mean. We can either specify the column numbers, or a set of names, or use the `:` to choose all variables between two columns.  \nThese all do the same:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> summarise(across(1:3, mean))\nsurvdat |> summarise(across(c(ppt,age,height), mean))\nsurvdat |> summarise(across(c(ppt:height), mean))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n    ppt   age height\n  <dbl> <dbl>  <dbl>\n1  38.5  24.3     NA\n```\n\n\n:::\n:::\n\n\n\n\nNote that we get an NA in the mean heights, because there is an NA in the data. So we need to specify that `na.rm=TRUE` when using the `mean()` function.  \nUnfortunately, this won't work:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> summarise(across(1:3, mean(na.rm=T)))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `summarise()`:\nℹ In argument: `across(1:3, mean(na.rm = T))`.\nCaused by error in `mean.default()`:\n! argument \"x\" is missing, with no default\n```\n\n\n:::\n:::\n\n\n\nThis is because when we open the brackets of `mean()`, it looks for the object we want to take the mean of. We can pass this through using `~` and `.`, like so: \n(You can kind of read the `.` as a place-holder for each variable)\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> summarise(across(1:3, ~mean(x=., na.rm=T)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n    ppt   age height\n  <dbl> <dbl>  <dbl>\n1  38.5  24.3   169.\n```\n\n\n:::\n:::\n\n\n\n\n\n\nUsing this syntax, we can apply the recoding we have seen above, but do it for all of the variables from `q1` to `q50`. All at once. like magic!  \nNote, we're not summarising here (i.e. we're not summarising down into a single value, we're just wanting to mutate the existing variables):  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  mutate(across(q1:q50,\n                ~case_match(., \n                \"Very Inaccurate\" ~ 1,\n                \"Moderately Inaccurate\" ~ 2,\n                \"Neither Accurate nor Inaccurate\" ~ 3,\n                \"Moderately Accurate\" ~ 4,\n                \"Very Accurate\" ~ 5)\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 53\n     ppt   age height    q1    q2    q3    q4    q5    q6    q7    q8    q9\n   <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    22    168     4     1     4     4     3     2     4     4     4\n 2     2    29    186     3     2     4     3     4     2     4     2     3\n 3     3    24     NA     1     1     3     2     2     4     4     3     4\n 4     4    26    175     1     2     4     4     5     2     4     4     2\n 5     5    28    182     1     1     3     4     4     5     3     3     2\n 6     6    27    159     4     1     2     1     1     3     4     1     3\n 7     7    27    149     2     1     4     5     4     4     4     4     3\n 8     8    23    178     2     3     5     5     3     3     2     1     1\n 9     9    28    176     3     2     5     5     5     3     5     3     3\n10    10    26    192     3     1     4     4     4     3     4     4     4\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>, q14 <dbl>,\n#   q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>, q20 <dbl>,\n#   q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>, q26 <dbl>,\n#   q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>, q32 <dbl>,\n#   q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>, q38 <dbl>,\n#   q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, q44 <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\n:::\n:::panel\n#### apply()\n\nBase R (the non-tidyverse stuff) has some really useful functions of the `apply()` family, that can allow us to do the same thing (apply an operation across a set of columns).  \n\nFor `apply()`, we give it an object like a dataframe, and we give it the dimension that we wish to perform the operation over. If we choose 1, it will do it for each row, and if we choose 2, it will do it for each column.  \nSo if we want the mean of the first 3 columns:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(survdat[,1:3], MARGIN=2, FUN=mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     ppt      age   height \n38.50000 24.28947       NA \n```\n\n\n:::\n:::\n\n\n\n\nMuch like with `across()`, this doesn't work because `mean()` now wants x explicitly given:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(survdat[,1:3], MARGIN=2, FUN=mean(na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in mean.default(na.rm = TRUE): argument \"x\" is missing, with no default\n```\n\n\n:::\n:::\n\n\n\nBut instead of the `~` and `.` stuff in tidyverse, the `apply()` wants us to explicitly define a little function, using `function()`.  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(survdat[,1:3], MARGIN=2, FUN=function(x) mean(x, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      ppt       age    height \n 38.50000  24.28947 169.36000 \n```\n\n\n:::\n:::\n\n\n\n(it's actually just convention that people use `function(x)`. we could use `function(kermit) mean(kermit, na.rm=TRUE)` and it would still work!)\n\nSo how do we do the recoding of all our questions? We simply apply a function like `case_match()` to each column! \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat[,4:53] <- apply(survdat[,4:53], MARGIN=2, FUN=function(x) \n  case_match(x, \n             \"Very Inaccurate\" ~ 1,\n             \"Moderately Inaccurate\" ~ 2,\n             \"Neither Accurate nor Inaccurate\" ~ 3,\n             \"Moderately Accurate\" ~ 4,\n             \"Very Accurate\" ~ 5)\n  )\nsurvdat\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 53\n     ppt   age height    q1    q2    q3    q4    q5    q6    q7    q8    q9\n   <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    22    168     4     1     4     4     3     2     4     4     4\n 2     2    29    186     3     2     4     3     4     2     4     2     3\n 3     3    24     NA     1     1     3     2     2     4     4     3     4\n 4     4    26    175     1     2     4     4     5     2     4     4     2\n 5     5    28    182     1     1     3     4     4     5     3     3     2\n 6     6    27    159     4     1     2     1     1     3     4     1     3\n 7     7    27    149     2     1     4     5     4     4     4     4     3\n 8     8    23    178     2     3     5     5     3     3     2     1     1\n 9     9    28    176     3     2     5     5     5     3     5     3     3\n10    10    26    192     3     1     4     4     4     3     4     4     4\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>, q14 <dbl>,\n#   q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>, q20 <dbl>,\n#   q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>, q26 <dbl>,\n#   q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>, q32 <dbl>,\n#   q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>, q38 <dbl>,\n#   q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, q44 <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n::::\n\n\n\n::: {.callout-caution collapse=\"true\"}\n#### optional: more complex functions\n\nWe can also define our custom functions outside of the use of `apply()`/`across()`, which can be useful if we have more complex functions. \n\nFor example, we can do the same recoding and _then_ standardise each variable, by explicitly defining a function that does that: \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrecodemysurvey <- function(question){\n  score = case_match(question, \n             \"Very Inaccurate\" ~ 1,\n             \"Moderately Inaccurate\" ~ 2,\n             \"Neither Accurate nor Inaccurate\" ~ 3,\n             \"Moderately Accurate\" ~ 4,\n             \"Very Accurate\" ~ 5)\n  score = (score - mean(score, na.rm = TRUE)) / sd(score, na.rm = TRUE)\n  return(score)\n}\n```\n:::\n\n\n\n\nAnd then using that function, either with:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |>\n  mutate(across(q1:q50, recodemysurvey))\n```\n:::\n\n\n\nor with:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(survdat[,4:53], 2, recodemysurvey)\n```\n:::\n\n\n\n\n\n:::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Reverse coding\n\nIt's very common for questionnaires to have a combination of questions for a construct, some of which are positively phrased and some which are negatively phrased. The idea here is to avoid introducing biases such as a bias to agree more than to disagree.   \n\nTake, for instance, `q1` and `q6` in our data, which are both measuring Extraversion: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndatadict |>\n  filter(variable %in% c(\"q1\",\"q6\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  variable question                     \n  <chr>    <chr>                        \n1 q1       [I am the life of the party.]\n2 q6       [I don't talk a lot.]        \n```\n\n\n:::\n:::\n\n\n\n\nSomeone very extraverted might respond to `q1` with \"Very Accurate\", and `q6` with \"Very Inaccurate\".  \n\nOften when we have a set of questions, we will want to reverse code the negatively phrased ones in order to have them all in the same direction. I.e. once they are recoded into numbers, we want the value 5 to represent highly extraverted on _both_ `q1` and `q6`.   \n\nHow do we reverse? We want any value of 1 to become 5, any value of 2 to become 4, 3 stays 3, 4 becomes 2, and 5 becomes 1.  \nWe can just subtract the value from 6!  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n6-c(1,2,3,4,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 4 3 2 1\n```\n\n\n:::\n:::\n\n\n\n\nSo to reverse code `q6`, we can simply subtract the variable from 6.  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  mutate(q6 = 6-q6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 53\n     ppt   age height    q1    q2    q3    q4    q5    q6    q7    q8    q9\n   <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    22    168     4     1     4     4     3     4     4     4     4\n 2     2    29    186     3     2     4     3     4     4     4     2     3\n 3     3    24     NA     1     1     3     2     2     2     4     3     4\n 4     4    26    175     1     2     4     4     5     4     4     4     2\n 5     5    28    182     1     1     3     4     4     1     3     3     2\n 6     6    27    159     4     1     2     1     1     3     4     1     3\n 7     7    27    149     2     1     4     5     4     2     4     4     3\n 8     8    23    178     2     3     5     5     3     3     2     1     1\n 9     9    28    176     3     2     5     5     5     3     5     3     3\n10    10    26    192     3     1     4     4     4     3     4     4     4\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>, q14 <dbl>,\n#   q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>, q20 <dbl>,\n#   q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>, q26 <dbl>,\n#   q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>, q32 <dbl>,\n#   q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>, q38 <dbl>,\n#   q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, q44 <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\nBut we're going to want to do this for all the negatively phrased questions in our survey. If we take a look at the [inventory page of the IPIP](https://ipip.ori.org/new_ipip-50-item-scale.htm){target=\"_blank\"}, we can see that these are all the even questions from 2 to 38, and then questions 39, 44, 46, and 49.  \n\nThat's a frustrating set!  \nLet's find a way to capture those. `seq(2,38,2)` will give us a sequence from 2 to 38 in steps of 2. So that gives us most of them. We can then just combine that with the other ones, and put \"q\" in front of each one to give us the variable names:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nneg_items <- paste0(\"q\", c(seq(2,38,2),39,44,46,49))\nneg_items\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"q2\"  \"q4\"  \"q6\"  \"q8\"  \"q10\" \"q12\" \"q14\" \"q16\" \"q18\" \"q20\" \"q22\" \"q24\"\n[13] \"q26\" \"q28\" \"q30\" \"q32\" \"q34\" \"q36\" \"q38\" \"q39\" \"q44\" \"q46\" \"q49\"\n```\n\n\n:::\n:::\n\n\n\n\n::::panelset\n:::panel\n#### using `across()`\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  mutate(across(all_of(neg_items),~6-.))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 53\n     ppt   age height    q1    q2    q3    q4    q5    q6    q7    q8    q9\n   <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    22    168     4     5     4     2     3     4     4     2     4\n 2     2    29    186     3     4     4     3     4     4     4     4     3\n 3     3    24     NA     1     5     3     4     2     2     4     3     4\n 4     4    26    175     1     4     4     2     5     4     4     2     2\n 5     5    28    182     1     5     3     2     4     1     3     3     2\n 6     6    27    159     4     5     2     5     1     3     4     5     3\n 7     7    27    149     2     5     4     1     4     2     4     2     3\n 8     8    23    178     2     3     5     1     3     3     2     5     1\n 9     9    28    176     3     4     5     1     5     3     5     3     3\n10    10    26    192     3     5     4     2     4     3     4     2     4\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>, q14 <dbl>,\n#   q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>, q20 <dbl>,\n#   q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>, q26 <dbl>,\n#   q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>, q32 <dbl>,\n#   q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>, q38 <dbl>,\n#   q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, q44 <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\n:::\n:::panel\n#### using `apply()`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat[,neg_items] <- apply(survdat[,neg_items], 2, function(x) 6-x)\nsurvdat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 53\n     ppt   age height    q1    q2    q3    q4    q5    q6    q7    q8    q9\n   <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    22    168     4     5     4     2     3     4     4     2     4\n 2     2    29    186     3     4     4     3     4     4     4     4     3\n 3     3    24     NA     1     5     3     4     2     2     4     3     4\n 4     4    26    175     1     4     4     2     5     4     4     2     2\n 5     5    28    182     1     5     3     2     4     1     3     3     2\n 6     6    27    159     4     5     2     5     1     3     4     5     3\n 7     7    27    149     2     5     4     1     4     2     4     2     3\n 8     8    23    178     2     3     5     1     3     3     2     5     1\n 9     9    28    176     3     4     5     1     5     3     5     3     3\n10    10    26    192     3     5     4     2     4     3     4     2     4\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>, q14 <dbl>,\n#   q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>, q20 <dbl>,\n#   q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>, q26 <dbl>,\n#   q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>, q32 <dbl>,\n#   q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>, q38 <dbl>,\n#   q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, q44 <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\n:::\n::::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Row scoring  \n\nVery often, people want to calculate a scale score. For instance, if people responded to each of 7 questions for a scale of generalised anxiety, then we would want to calculate a 'generalised anxiety score' by adding up their responses 5+1+2+4+4+3+5 = 24.  \n\nThere are handy functions that can do quick row scoring: `rowSums()` and `rowMeans()`.  \n\nFor instance, to calculate each person's (each row of our data is a person) sum of the questions 1 to 5, we can use any of:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# tidyverse\nsurvdat |> select(q1:q5) |> rowSums()\n# indexing:\nrowSums(survdat[,c(\"q1\",\"q2\",\"q3\",\"q4\",\"q5\")])\n# concise indexing\nrowSums(survdat[, paste0(\"q\",1:5)])\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 18 18 15 16 15 17 16 14 18 18 17  8 16 13 11 14 16 18 20 17 13 16 14 17 17\n[26] 18 19 14 16 12 18 20 18 17 15 15  7 12 15 15 19 17 22 20 20 19 16 14 17 10\n[51] 15 18 19 17 10 19 16 12 22 16 12 15 14 19  9  9 17 20 15 17 19 16 18 16 13\n[76] 14\n```\n\n\n:::\n:::\n\n\n\n\nFrom the [inventory page of the IPIP](https://ipip.ori.org/new_ipip-50-item-scale.htm){target=\"_blank\"}, we can see that the questions are ordered such that questions 1, 6, 11, ..., all correspond to Extraversion, questions 2, 7, 12, ... all correspond to Agreeableness, and so on.  \n\nWe can use things like `seq()` to capture the relevant numbers of each question:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# sequence from 1 to 50 in steps of 5\nseq(1,50,5) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  6 11 16 21 26 31 36 41 46\n```\n\n\n:::\n\n```{.r .cell-code}\n# sequence from 1 to 50 in steps of 5\nseq(2,50,5) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  7 12 17 22 27 32 37 42 47\n```\n\n\n:::\n:::\n\n\n\n\n\nWhich means we can get the scores for each personality trait using something such as: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat$extr <- rowSums(survdat[, paste0(\"q\",seq(1,50,5))])\nsurvdat$agree <- rowSums(survdat[, paste0(\"q\",seq(2,50,5))])\nsurvdat$consc <- rowSums(survdat[, paste0(\"q\",seq(3,50,5))])\nsurvdat$emot_s <- rowSums(survdat[, paste0(\"q\",seq(4,50,5))])\nsurvdat$imagin <- rowSums(survdat[, paste0(\"q\",seq(5,50,5))])\n```\n:::\n\n\n\n\nAnd we can quickly examine all our scale scores:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(psych)\nsurvdat |> \n  select(extr:imagin) |>\n  pairs.panels()\n```\n\n::: {.cell-output-display}\n![](00_qdata_files/figure-html/unnamed-chunk-41-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# More Rowwise Stuff\n\nWe can also find out useful information for each row about things like how much missingness there is:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# is.na will turn all NA entries to \"TRUE\", and all non-missing values to FALSE. \n# then we sum them up across the rows and it will give us how many NAs are in each row, across the 50 questions!  \nrowSums( is.na( survdat[, paste0(\"q\",1:50)] ) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0\n[39] 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n:::\n\n\n\n\n\nOccasionally, you might find that you want to do row-wise operations that don't have easy functions like `rowSums`. \nIn these cases, the tidyverse function `rowwise()` can be useful in that it applies an operation to one row at a time: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  rowwise() |>\n  mutate(\n    # find the minimum score given for each row\n    maxscore = min(across(q1:q50)), \n    # put the column after the height column\n    .after = height\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 59\n# Rowwise: \n     ppt   age height maxscore    q1    q2    q3    q4    q5    q6    q7    q8\n   <dbl> <dbl>  <dbl>    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    22    168        1     4     5     4     2     3     4     4     2\n 2     2    29    186        2     3     4     4     3     4     4     4     4\n 3     3    24     NA        1     1     5     3     4     2     2     4     3\n 4     4    26    175        1     1     4     4     2     5     4     4     2\n 5     5    28    182        1     1     5     3     2     4     1     3     3\n 6     6    27    159        1     4     5     2     5     1     3     4     5\n 7     7    27    149        1     2     5     4     1     4     2     4     2\n 8     8    23    178        1     2     3     5     1     3     3     2     5\n 9     9    28    176        1     3     4     5     1     5     3     5     3\n10    10    26    192        1     3     5     4     2     4     3     4     2\n# ℹ 66 more rows\n# ℹ 47 more variables: q9 <dbl>, q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>,\n#   q14 <dbl>, q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>,\n#   q20 <dbl>, q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>,\n#   q26 <dbl>, q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>,\n#   q32 <dbl>, q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>,\n#   q38 <dbl>, q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\nAlternatively, `apply()` to the rescue again!  \n`MARGIN = 1` here applies the operation across rows:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(survdat[,paste0(\"q\",1:50)], MARGIN = 1, FUN = min)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  1  1  1  1  1  1  1  1 NA  1  1  1 NA  1  1  1  2  1  1  1  1  1  1\n[26]  1  1  1  2 NA  1  1  1  1  1  1  1  1  1  1  2  2  2  2  1  1  1 NA  1  1\n[51]  1  1  2  1  1  1  1  1  1  1  1  1  1  1  1  1  2  1  2  1  1  1  1  1  1\n[76]  1\n```\n\n\n:::\n:::\n",
    "supporting": [
      "00_qdata_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/panelset-0.3.0/panelset.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/panelset-0.3.0/panelset.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}