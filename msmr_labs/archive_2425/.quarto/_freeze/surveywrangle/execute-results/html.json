{
  "hash": "065e88ccdebf3a660ffabba280a3f908",
  "result": {
    "markdown": "---\ntitle: \"Data wrangling for surveys & questionnaires\"\nauthor: \"hello\"\nparams: \n    SHOW_SOLS: TRUE\n    TOGGLE: TRUE\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\nQuestionnaire data often comes to us in 'wide' format, which is often how we want it for many of the analytical methods we use with questionnaire data. However, working with data in the wide format comes with some specific challenges that generally arise because we have lots and lots of variables. \n\nBelow we will walk through some of the common ways we want to wrangle and clean questionnaire data.  \n\n\n# Variable names\n\nVery often, the data might come to us with huge long names that correspond to the question being asked.  \nFor instance: \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat <- read_csv(\"data/surveywrangle.csv\") |> mutate(ppt = 1:n())\nsurvdat <- survdat[,c(60,3:52)]\nnames(survdat) <- gsub(\"Describe yourself as you generally are now, not as you wish to be in the future. Describe yourself as you honestly see yourself, in relation to other people you know of the same age and sex as you are. Remember that responses are anonymised. Please indicate the accuracy for each statement in how it describes you.  \",\"\",names(survdat))\nsurvdat$age = round(runif(nrow(survdat),20,29))\nsurvdat$height = round(rnorm(nrow(survdat),168,12))\nsurvdat$height[3]<-NA\nsurvdat <- survdat |> relocate(age,height,.after=ppt)\nhead(survdat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 53\n    ppt   age height `[I am the life of the party.]` [I feel little concern fo…¹\n  <int> <dbl>  <dbl> <chr>                           <chr>                      \n1     1    28    151 Moderately Accurate             Very Inaccurate            \n2     2    25    158 Neither Accurate nor Inaccurate Moderately Inaccurate      \n3     3    23     NA Very Inaccurate                 Very Inaccurate            \n4     4    25    165 Very Inaccurate                 Moderately Inaccurate      \n5     5    21    160 Very Inaccurate                 Very Inaccurate            \n6     6    20    180 Moderately Accurate             Very Inaccurate            \n# ℹ abbreviated name: ¹​`[I feel little concern for others.]`\n# ℹ 48 more variables: `[I am always prepared.]` <chr>,\n#   `[I get stressed out easily.]` <chr>, `[I have a rich vocabulary.]` <chr>,\n#   `[I don't talk a lot.]` <chr>, `[I am interested in people.]` <chr>,\n#   `[I leave my belongings around.]` <chr>,\n#   `[I am relaxed most of the time.]` <chr>,\n#   `[I have difficulty understanding abstract ideas.]` <chr>, …\n```\n:::\n:::\n\n\nOften, we want our variables to have some easier names to work with, e.g. \"q1\", \"q2\" etc.  \n\nBecause it's often important to keep track of what each question actually asks, it can be useful to create a little dictionary to map our new variable names to the current names.  \n\nIn our data, we have variables called `ppt`, `age` and `height`, and then 50 variables corresponding to 50 different questions.  \nWhat I plan to do is rename them to `ppt`,`age`,`height`,`q1`, `q2`, ..., `q50`.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndatadict <- \n  tibble(\n    # these are my proposed new names\n    variable = c(\"ppt\",\"age\",\"height\", \n                 paste0(\"q\", 1:50)),\n    # current names\n    question = names(survdat)\n  )\nhead(datadict)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  variable question                           \n  <chr>    <chr>                              \n1 ppt      ppt                                \n2 age      age                                \n3 height   height                             \n4 q1       [I am the life of the party.]      \n5 q2       [I feel little concern for others.]\n6 q3       [I am always prepared.]            \n```\n:::\n:::\n\n\nIf we want to, we can write this to a .csv file so that we can keep it somewhere useful.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwrite_csv(datadict, file = \"survey_dictionary.csv\")\n```\n:::\n\n\nNow we have created our record, we can actually change the names of the variables:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnames(survdat)[4:53] <- paste0(\"q\", 1:50)\nhead(survdat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 53\n    ppt   age height q1    q2    q3    q4    q5    q6    q7    q8    q9    q10  \n  <int> <dbl>  <dbl> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr>\n1     1    28    151 Mode… Very… Mode… Mode… Neit… Mode… Mode… Mode… Mode… Neit…\n2     2    25    158 Neit… Mode… Mode… Neit… Mode… Mode… Mode… Mode… Neit… Neit…\n3     3    23     NA Very… Very… Neit… Mode… Mode… Mode… Mode… Neit… Mode… Very…\n4     4    25    165 Very… Mode… Mode… Mode… Very… Mode… Mode… Mode… Mode… Mode…\n5     5    21    160 Very… Very… Neit… Mode… Mode… Very… Neit… Neit… Mode… Mode…\n6     6    20    180 Mode… Very… Mode… Very… Very… Neit… Mode… Very… Neit… Mode…\n# ℹ 40 more variables: q11 <chr>, q12 <chr>, q13 <chr>, q14 <chr>, q15 <chr>,\n#   q16 <chr>, q17 <chr>, q18 <chr>, q19 <chr>, q20 <chr>, q21 <chr>,\n#   q22 <chr>, q23 <chr>, q24 <chr>, q25 <chr>, q26 <chr>, q27 <chr>,\n#   q28 <chr>, q29 <chr>, q30 <chr>, q31 <chr>, q32 <chr>, q33 <chr>,\n#   q34 <chr>, q35 <chr>, q36 <chr>, q37 <chr>, q38 <chr>, q39 <chr>,\n#   q40 <chr>, q41 <chr>, q42 <chr>, q43 <chr>, q44 <chr>, q45 <chr>,\n#   q46 <chr>, q47 <chr>, q48 <chr>, q49 <chr>, q50 <chr>\n```\n:::\n:::\n\n\n# Variable recoding\n\nFirst things first, all of the questions are scored on a 5 point likert^[Technically this is pronounced \"LICK-URT\" and not \"LIE-KURT\". It's named after [Dr Rensis Likert](https://en.wikipedia.org/wiki/Rensis_Likert){target=\"_blank\"}, and that's how he pronounced his name!] scale. \n\nThe data has come out of whatever questionnaire software we used and it's showing the chosen response for each question in words, e.g. \"Moderately Accurate\". But we are going to turn them into numbers so that they are easier to work with.  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n```{=html}\n<div id=\"fxlylrpbtl\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#fxlylrpbtl table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#fxlylrpbtl thead, #fxlylrpbtl tbody, #fxlylrpbtl tfoot, #fxlylrpbtl tr, #fxlylrpbtl td, #fxlylrpbtl th {\n  border-style: none;\n}\n\n#fxlylrpbtl p {\n  margin: 0;\n  padding: 0;\n}\n\n#fxlylrpbtl .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#fxlylrpbtl .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#fxlylrpbtl .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#fxlylrpbtl .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#fxlylrpbtl .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#fxlylrpbtl .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#fxlylrpbtl .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#fxlylrpbtl .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#fxlylrpbtl .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#fxlylrpbtl .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#fxlylrpbtl .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#fxlylrpbtl .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#fxlylrpbtl .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#fxlylrpbtl .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#fxlylrpbtl .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#fxlylrpbtl .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#fxlylrpbtl .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#fxlylrpbtl .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#fxlylrpbtl .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#fxlylrpbtl .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#fxlylrpbtl .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#fxlylrpbtl .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#fxlylrpbtl .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#fxlylrpbtl .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#fxlylrpbtl .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#fxlylrpbtl .gt_left {\n  text-align: left;\n}\n\n#fxlylrpbtl .gt_center {\n  text-align: center;\n}\n\n#fxlylrpbtl .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#fxlylrpbtl .gt_font_normal {\n  font-weight: normal;\n}\n\n#fxlylrpbtl .gt_font_bold {\n  font-weight: bold;\n}\n\n#fxlylrpbtl .gt_font_italic {\n  font-style: italic;\n}\n\n#fxlylrpbtl .gt_super {\n  font-size: 65%;\n}\n\n#fxlylrpbtl .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#fxlylrpbtl .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#fxlylrpbtl .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#fxlylrpbtl .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#fxlylrpbtl .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#fxlylrpbtl .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#fxlylrpbtl .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    \n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"response\">response</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"score\">score</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"response\" class=\"gt_row gt_left\">Very Inaccurate</td>\n<td headers=\"score\" class=\"gt_row gt_right\">1</td></tr>\n    <tr><td headers=\"response\" class=\"gt_row gt_left\">Moderately Inaccurate</td>\n<td headers=\"score\" class=\"gt_row gt_right\">2</td></tr>\n    <tr><td headers=\"response\" class=\"gt_row gt_left\">Neither Accurate nor Inaccurate</td>\n<td headers=\"score\" class=\"gt_row gt_right\">3</td></tr>\n    <tr><td headers=\"response\" class=\"gt_row gt_left\">Moderately Accurate</td>\n<td headers=\"score\" class=\"gt_row gt_right\">4</td></tr>\n    <tr><td headers=\"response\" class=\"gt_row gt_left\">Very Accurate</td>\n<td headers=\"score\" class=\"gt_row gt_right\">5</td></tr>\n  </tbody>\n  \n  \n</table>\n</div>\n```\n:::\n:::\n\n\nYou might be shouting at the screen here that by turning these words into numbers we're about to turn a set of ordered categories into an interval scale. Is \"Moderately Inaccurate\" really 2 x \"Very Inaccurate\"? You might be right to have this intuition - it's a contentious issue! In psychology, in which questionnaire based methods are everywhere, an often used rule of thumb is that likert data with $\\geq 5$ levels can be treated as if they are continuous without unduly influencing results (see [Johnson, D.R., & Creech, J.C. (1983). Ordinal measures in multiple indicator models: A simulation study of categorization error](https://discovered.ed.ac.uk/permalink/f/1s15qcp/TN_cdi_crossref_primary_10_2307_2095231){target=\"_blank\"}).  \n\nLet's push on and see how we can do this sort of recoding.  \nFirst we'll do it for just one variable. As always in R, there are lots of ways to do the same thing. All of these approaches follows an if-else type logic - \"if we have 'moderately inaccurate', make it '2', and if we have 'very inaccurate, make it 1, and if ... \".  \n\n::::panelset\n:::panel\n#### `ifelse()`  \nThis is the most cumbersome way to do this logic as it requires multiple nested ifelse statements.  \nTo ensure that anything that isn't one of the 5 valid response options gets to be an NA, we have the final \"else\" specifying that if it's none of the prespecified options, make it an NA\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |>\n  mutate(\n    q1 = ifelse(q1 == \"Very Inaccurate\", 1,\n                ifelse(q1 == \"Moderately Inaccurate\", 2, \n                       ifelse( q1 == \"Neither Accurate nor Inaccurate\", 3, \n                               ifelse(q1 == \"Moderately Accurate\", 4, \n                                      ifelse(q1 == \"Very Accurate\", 5, NA)))))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 76 × 53\n     ppt   age height    q1 q2         q3    q4    q5    q6    q7    q8    q9   \n   <int> <dbl>  <dbl> <dbl> <chr>      <chr> <chr> <chr> <chr> <chr> <chr> <chr>\n 1     1    28    151     4 Very Inac… Mode… Mode… Neit… Mode… Mode… Mode… Mode…\n 2     2    25    158     3 Moderatel… Mode… Neit… Mode… Mode… Mode… Mode… Neit…\n 3     3    23     NA     1 Very Inac… Neit… Mode… Mode… Mode… Mode… Neit… Mode…\n 4     4    25    165     1 Moderatel… Mode… Mode… Very… Mode… Mode… Mode… Mode…\n 5     5    21    160     1 Very Inac… Neit… Mode… Mode… Very… Neit… Neit… Mode…\n 6     6    20    180     4 Very Inac… Mode… Very… Very… Neit… Mode… Very… Neit…\n 7     7    27    140     2 Very Inac… Mode… Very… Mode… Mode… Mode… Mode… Neit…\n 8     8    28    167     2 Neither A… Very… Very… Neit… Neit… Mode… Very… Very…\n 9     9    22    163     3 Moderatel… Very… Very… Very… Neit… Very… Neit… Neit…\n10    10    25    163     3 Very Inac… Mode… Mode… Mode… Neit… Mode… Mode… Mode…\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <chr>, q11 <chr>, q12 <chr>, q13 <chr>, q14 <chr>,\n#   q15 <chr>, q16 <chr>, q17 <chr>, q18 <chr>, q19 <chr>, q20 <chr>,\n#   q21 <chr>, q22 <chr>, q23 <chr>, q24 <chr>, q25 <chr>, q26 <chr>,\n#   q27 <chr>, q28 <chr>, q29 <chr>, q30 <chr>, q31 <chr>, q32 <chr>,\n#   q33 <chr>, q34 <chr>, q35 <chr>, q36 <chr>, q37 <chr>, q38 <chr>,\n#   q39 <chr>, q40 <chr>, q41 <chr>, q42 <chr>, q43 <chr>, q44 <chr>, …\n```\n:::\n:::\n\n:::\n:::panel\n#### case_when\n\n`case_when()` follows this same logic as `ifelse()` but makes for easier reading (and writing). Each line is a statement saying \"if [variable] is equal to [value], then return [new value]\". The final entry here `TRUE ~ NA` is a bit like saying \"and if it is anything else, make it an NA\". \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |>\n  mutate(\n    q1 = case_when(\n      q1 == \"Very Inaccurate\" ~ 1,\n      q1 == \"Moderately Inaccurate\" ~ 2,\n      q1 == \"Neither Accurate nor Inaccurate\" ~ 3,\n      q1 == \"Moderately Accurate\" ~ 4,\n      q1 == \"Very Accurate\" ~ 5,\n      TRUE ~ NA\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 76 × 53\n     ppt   age height    q1 q2         q3    q4    q5    q6    q7    q8    q9   \n   <int> <dbl>  <dbl> <dbl> <chr>      <chr> <chr> <chr> <chr> <chr> <chr> <chr>\n 1     1    28    151     4 Very Inac… Mode… Mode… Neit… Mode… Mode… Mode… Mode…\n 2     2    25    158     3 Moderatel… Mode… Neit… Mode… Mode… Mode… Mode… Neit…\n 3     3    23     NA     1 Very Inac… Neit… Mode… Mode… Mode… Mode… Neit… Mode…\n 4     4    25    165     1 Moderatel… Mode… Mode… Very… Mode… Mode… Mode… Mode…\n 5     5    21    160     1 Very Inac… Neit… Mode… Mode… Very… Neit… Neit… Mode…\n 6     6    20    180     4 Very Inac… Mode… Very… Very… Neit… Mode… Very… Neit…\n 7     7    27    140     2 Very Inac… Mode… Very… Mode… Mode… Mode… Mode… Neit…\n 8     8    28    167     2 Neither A… Very… Very… Neit… Neit… Mode… Very… Very…\n 9     9    22    163     3 Moderatel… Very… Very… Very… Neit… Very… Neit… Neit…\n10    10    25    163     3 Very Inac… Mode… Mode… Mode… Neit… Mode… Mode… Mode…\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <chr>, q11 <chr>, q12 <chr>, q13 <chr>, q14 <chr>,\n#   q15 <chr>, q16 <chr>, q17 <chr>, q18 <chr>, q19 <chr>, q20 <chr>,\n#   q21 <chr>, q22 <chr>, q23 <chr>, q24 <chr>, q25 <chr>, q26 <chr>,\n#   q27 <chr>, q28 <chr>, q29 <chr>, q30 <chr>, q31 <chr>, q32 <chr>,\n#   q33 <chr>, q34 <chr>, q35 <chr>, q36 <chr>, q37 <chr>, q38 <chr>,\n#   q39 <chr>, q40 <chr>, q41 <chr>, q42 <chr>, q43 <chr>, q44 <chr>, …\n```\n:::\n:::\n\n:::\n:::panel\n#### `case_match()`\n\nThe `ifelse()` and `case_when()` functions are much more generalised - we can say \"if x is 1 make it 1, and if y is 2 make it 0, and if z is ... \".  \n\nHowever, in the task at hand, all of our \"if\" questions apply to the value of the same variable. The `case_match()` function is perfectly designed for this:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  mutate(\n    q1 = case_match(q1, \n                \"Very Inaccurate\" ~ 1,\n                \"Moderately Inaccurate\" ~ 2,\n                \"Neither Accurate nor Inaccurate\" ~ 3,\n                \"Moderately Accurate\" ~ 4,\n                \"Very Accurate\" ~ 5)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 76 × 53\n     ppt   age height    q1 q2         q3    q4    q5    q6    q7    q8    q9   \n   <int> <dbl>  <dbl> <dbl> <chr>      <chr> <chr> <chr> <chr> <chr> <chr> <chr>\n 1     1    28    151     4 Very Inac… Mode… Mode… Neit… Mode… Mode… Mode… Mode…\n 2     2    25    158     3 Moderatel… Mode… Neit… Mode… Mode… Mode… Mode… Neit…\n 3     3    23     NA     1 Very Inac… Neit… Mode… Mode… Mode… Mode… Neit… Mode…\n 4     4    25    165     1 Moderatel… Mode… Mode… Very… Mode… Mode… Mode… Mode…\n 5     5    21    160     1 Very Inac… Neit… Mode… Mode… Very… Neit… Neit… Mode…\n 6     6    20    180     4 Very Inac… Mode… Very… Very… Neit… Mode… Very… Neit…\n 7     7    27    140     2 Very Inac… Mode… Very… Mode… Mode… Mode… Mode… Neit…\n 8     8    28    167     2 Neither A… Very… Very… Neit… Neit… Mode… Very… Very…\n 9     9    22    163     3 Moderatel… Very… Very… Very… Neit… Very… Neit… Neit…\n10    10    25    163     3 Very Inac… Mode… Mode… Mode… Neit… Mode… Mode… Mode…\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <chr>, q11 <chr>, q12 <chr>, q13 <chr>, q14 <chr>,\n#   q15 <chr>, q16 <chr>, q17 <chr>, q18 <chr>, q19 <chr>, q20 <chr>,\n#   q21 <chr>, q22 <chr>, q23 <chr>, q24 <chr>, q25 <chr>, q26 <chr>,\n#   q27 <chr>, q28 <chr>, q29 <chr>, q30 <chr>, q31 <chr>, q32 <chr>,\n#   q33 <chr>, q34 <chr>, q35 <chr>, q36 <chr>, q37 <chr>, q38 <chr>,\n#   q39 <chr>, q40 <chr>, q41 <chr>, q42 <chr>, q43 <chr>, q44 <chr>, …\n```\n:::\n:::\n\n\nIf we wanted to collapse levels, the syntax works like so:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  mutate(\n    q1 = case_match(q1, \n                    c(\"Very Inaccurate\",\"Moderately Inaccurate\") ~ 1,\n                    \"Neither Accurate nor Inaccurate\" ~ 2,\n                    c(\"Moderately Accurate\",\"Very Accurate\") ~ 3\n    )\n  )\n```\n:::\n\n\n\n:::\n\n::::\n\n\n# Applying the same operation across variables\n\nNow that we know how to recode a variable, what if we want to do it for all 50 questions? We don't want to do it manually, because that would be hugely inefficient:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> mutate(\n  q1 = case_match(q1,\n    ...\n    ..\n    ...\n  ),\n  q2 = case_match(q2,\n    ...\n    ..\n    ...\n  ),\n  ..\n)\n```\n:::\n\n\nThere are various ways to do this, but the two main ones are by utilising __tidyverse__'s `across()` function, or by using the Base R `apply()` function.  \n\n::::panelset\n:::panel\n#### `across()`\n\nThe `across()` function works inside other tidyverse functions like `summarise()` and `mutate()`, and allows us to do the same operation across a set of columns.  \n\nThe syntax is (with either summarise or mutate):  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata |>\n  mutate(across(variables, operation))\n```\n:::\n\n\nAs an example, suppose i wanted to summarise across the first three variables (`ppt`,`age`, and `height`) and get the mean. We can either specify the column numbers, or a set of names, or use the `:` to choose all variables between two columns.  \nThese all do the same:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> summarise(across(1:3, mean))\nsurvdat |> summarise(across(c(ppt,age,height), mean))\nsurvdat |> summarise(across(c(ppt:height), mean))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n    ppt   age height\n  <dbl> <dbl>  <dbl>\n1  38.5  24.2     NA\n```\n:::\n:::\n\n\nNote that we get an NA in the mean heights, because there is an NA in the data. So we need to specify that `na.rm=TRUE` when using the `mean()` function.  \nUnfortunately, this won't work:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> summarise(across(1:3, mean(na.rm=T)))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `summarise()`:\nℹ In argument: `across(1:3, mean(na.rm = T))`.\nCaused by error in `mean.default()`:\n! argument \"x\" is missing, with no default\n```\n:::\n:::\n\nThis is because when we open the brackets of `mean()`, it looks for the object we want to take the mean of. We can pass this through using `~` and `.`, like so: \n(You can kind of read the `.` as a place-holder for each variable)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> summarise(across(1:3, ~mean(x=., na.rm=T)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n    ppt   age height\n  <dbl> <dbl>  <dbl>\n1  38.5  24.2   169.\n```\n:::\n:::\n\n\n\n\nUsing this syntax, we can apply the recoding we have seen above, but do it for all of the variables from `q1` to `q50`. All at once. like magic!  \nNote, we're not summarising here (i.e. we're not summarising down into a single value, we're just wanting to mutate the existing variables):  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  mutate(across(q1:q50,\n                ~case_match(., \n                \"Very Inaccurate\" ~ 1,\n                \"Moderately Inaccurate\" ~ 2,\n                \"Neither Accurate nor Inaccurate\" ~ 3,\n                \"Moderately Accurate\" ~ 4,\n                \"Very Accurate\" ~ 5)\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 76 × 53\n     ppt   age height    q1    q2    q3    q4    q5    q6    q7    q8    q9\n   <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    28    151     4     1     4     4     3     2     4     4     4\n 2     2    25    158     3     2     4     3     4     2     4     2     3\n 3     3    23     NA     1     1     3     2     2     4     4     3     4\n 4     4    25    165     1     2     4     4     5     2     4     4     2\n 5     5    21    160     1     1     3     4     4     5     3     3     2\n 6     6    20    180     4     1     2     1     1     3     4     1     3\n 7     7    27    140     2     1     4     5     4     4     4     4     3\n 8     8    28    167     2     3     5     5     3     3     2     1     1\n 9     9    22    163     3     2     5     5     5     3     5     3     3\n10    10    25    163     3     1     4     4     4     3     4     4     4\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>, q14 <dbl>,\n#   q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>, q20 <dbl>,\n#   q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>, q26 <dbl>,\n#   q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>, q32 <dbl>,\n#   q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>, q38 <dbl>,\n#   q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, q44 <dbl>, …\n```\n:::\n:::\n\n\n:::\n:::panel\n#### apply\n\nBase R (the non-tidyverse stuff) has some really useful functions of the `apply()` family, that can allow us to do the same thing (apply an operation across a set of columns).  \n\nFor `apply()`, we give it an object like a dataframe, and we give it the dimension that we wish to perform the operation over. If we choose 1, it will do it for each row, and if we choose 2, it will do it for each column.  \nSo if we want the mean of the first 3 columns:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(survdat[,1:3], MARGIN=2, FUN=mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     ppt      age   height \n38.50000 24.18421       NA \n```\n:::\n:::\n\n\nMuch like with `across()`, this doesn't work because `mean()` now wants x explicitly given:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(survdat[,1:3], MARGIN=2, FUN=mean(na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mean.default(na.rm = TRUE): argument \"x\" is missing, with no default\n```\n:::\n:::\n\nBut instead of the `~` and `.` stuff in tidyverse, the `apply()` wants us to explicitly define a little function, using `function()`.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(survdat[,1:3], MARGIN=2, FUN=function(x) mean(x, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      ppt       age    height \n 38.50000  24.18421 168.68000 \n```\n:::\n:::\n\n(it's actually just convention that people use `function(x)`. we could use `function(kermit) mean(kermit, na.rm=TRUE)` and it would still work!)\n\nSo how do we do the recoding of all our questions? We simply apply a function like `case_match()` to each column! \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat[,4:53] <- apply(survdat[,4:53], MARGIN=2, FUN=function(x) \n  case_match(x, \n             \"Very Inaccurate\" ~ 1,\n             \"Moderately Inaccurate\" ~ 2,\n             \"Neither Accurate nor Inaccurate\" ~ 3,\n             \"Moderately Accurate\" ~ 4,\n             \"Very Accurate\" ~ 5)\n  )\nsurvdat\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 76 × 53\n     ppt   age height    q1    q2    q3    q4    q5    q6    q7    q8    q9\n   <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    28    151     4     1     4     4     3     2     4     4     4\n 2     2    25    158     3     2     4     3     4     2     4     2     3\n 3     3    23     NA     1     1     3     2     2     4     4     3     4\n 4     4    25    165     1     2     4     4     5     2     4     4     2\n 5     5    21    160     1     1     3     4     4     5     3     3     2\n 6     6    20    180     4     1     2     1     1     3     4     1     3\n 7     7    27    140     2     1     4     5     4     4     4     4     3\n 8     8    28    167     2     3     5     5     3     3     2     1     1\n 9     9    22    163     3     2     5     5     5     3     5     3     3\n10    10    25    163     3     1     4     4     4     3     4     4     4\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>, q14 <dbl>,\n#   q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>, q20 <dbl>,\n#   q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>, q26 <dbl>,\n#   q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>, q32 <dbl>,\n#   q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>, q38 <dbl>,\n#   q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, q44 <dbl>, …\n```\n:::\n:::\n\n\n\n:::\n::::\n\n\n\n::: {.callout-caution collapse=\"true\"}\n#### optional: more complex functions\n\nWe can also define our custom functions outside of the use of `apply()`/`across()`, which can be useful if we have more complex functions. \n\nFor example, we can do the same recoding and _then_ standardise each variable, by explicitly defining a function that does that: \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrecodemysurvey <- function(question){\n  score = case_match(question, \n             \"Very Inaccurate\" ~ 1,\n             \"Moderately Inaccurate\" ~ 2,\n             \"Neither Accurate nor Inaccurate\" ~ 3,\n             \"Moderately Accurate\" ~ 4,\n             \"Very Accurate\" ~ 5)\n  score = (score - mean(score, na.rm = TRUE)) / sd(score, na.rm = TRUE)\n  return(score)\n}\n```\n:::\n\n\nAnd then using that function, either with:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |>\n  mutate(across(q1:q50, recodemysurvey))\n```\n:::\n\nor with:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(survdat[,4:53], 2, recodemysurvey)\n```\n:::\n\n\n\n:::\n\n\n# reverse coding\n\nIt's very common for questionnaires to have a combination of questions for a construct, some of which are positively phrased and some which are negatively phrased. The idea here is to avoid introducing biases such as a bias to agree more than to disagree.   \n\nTake, for instance, `q1` and `q6` in our data, which are both measuring Extraversion: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndatadict |>\n  filter(variable %in% c(\"q1\",\"q6\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  variable question                     \n  <chr>    <chr>                        \n1 q1       [I am the life of the party.]\n2 q6       [I don't talk a lot.]        \n```\n:::\n:::\n\n\nSomeone very extraverted might respond to `q1` with \"Very Accurate\", and `q6` with \"Very Inaccurate\".  \n\nOften when we have a set of questions, we will want to reverse code the negatively phrased ones in order to have them all in the same direction. I.e. once they are recoded into numbers, we want the value 5 to represent highly extraverted on _both_ `q1` and `q6`.   \n\nHow do we reverse? We want any value of 1 to become 5, any value of 2 to become 4, 3 stays 3, 4 becomes 2, and 5 becomes 1.  \nWe can just subtract the value from 6!  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n6-c(1,2,3,4,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 4 3 2 1\n```\n:::\n:::\n\n\nSo to reverse code `q6`, we can simply subtract the variable from 6.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  mutate(q6 = 6-q6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 76 × 53\n     ppt   age height    q1    q2    q3    q4    q5    q6    q7    q8    q9\n   <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    28    151     4     1     4     4     3     4     4     4     4\n 2     2    25    158     3     2     4     3     4     4     4     2     3\n 3     3    23     NA     1     1     3     2     2     2     4     3     4\n 4     4    25    165     1     2     4     4     5     4     4     4     2\n 5     5    21    160     1     1     3     4     4     1     3     3     2\n 6     6    20    180     4     1     2     1     1     3     4     1     3\n 7     7    27    140     2     1     4     5     4     2     4     4     3\n 8     8    28    167     2     3     5     5     3     3     2     1     1\n 9     9    22    163     3     2     5     5     5     3     5     3     3\n10    10    25    163     3     1     4     4     4     3     4     4     4\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>, q14 <dbl>,\n#   q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>, q20 <dbl>,\n#   q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>, q26 <dbl>,\n#   q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>, q32 <dbl>,\n#   q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>, q38 <dbl>,\n#   q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, q44 <dbl>, …\n```\n:::\n:::\n\n\nBut we're going to want to do this for all the negatively phrased questions in our survey. If we take a look at the [inventory page of the IPIP](https://ipip.ori.org/new_ipip-50-item-scale.htm){target=\"_blank\"}, we can see that these are all the even questions from 2 to 38, and then questions 39, 44, 46, and 49.  \n\nThat's a frustrating set!  \nLet's find a way to capture those. `seq(2,38,2)` will give us a sequence from 2 to 38 in steps of 2. So that gives us most of them. We can then just combine that with the other ones, and put \"q\" in front of each one to give us the variable names:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nneg_items <- paste0(\"q\", c(seq(2,38,2),39,44,46,49))\nneg_items\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"q2\"  \"q4\"  \"q6\"  \"q8\"  \"q10\" \"q12\" \"q14\" \"q16\" \"q18\" \"q20\" \"q22\" \"q24\"\n[13] \"q26\" \"q28\" \"q30\" \"q32\" \"q34\" \"q36\" \"q38\" \"q39\" \"q44\" \"q46\" \"q49\"\n```\n:::\n:::\n\n\n::::panelset\n:::panel\n#### using `across()`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat |> \n  mutate(across(neg_items,~6-.))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 76 × 53\n     ppt   age height    q1    q2    q3    q4    q5    q6    q7    q8    q9\n   <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    28    151     4     5     4     2     3     4     4     2     4\n 2     2    25    158     3     4     4     3     4     4     4     4     3\n 3     3    23     NA     1     5     3     4     2     2     4     3     4\n 4     4    25    165     1     4     4     2     5     4     4     2     2\n 5     5    21    160     1     5     3     2     4     1     3     3     2\n 6     6    20    180     4     5     2     5     1     3     4     5     3\n 7     7    27    140     2     5     4     1     4     2     4     2     3\n 8     8    28    167     2     3     5     1     3     3     2     5     1\n 9     9    22    163     3     4     5     1     5     3     5     3     3\n10    10    25    163     3     5     4     2     4     3     4     2     4\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>, q14 <dbl>,\n#   q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>, q20 <dbl>,\n#   q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>, q26 <dbl>,\n#   q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>, q32 <dbl>,\n#   q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>, q38 <dbl>,\n#   q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, q44 <dbl>, …\n```\n:::\n:::\n\n\n:::\n:::panel\n#### using `apply()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsurvdat[,neg_items] <- apply(survdat[,neg_items], 2, function(x) 6-x)\nsurvdat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 76 × 53\n     ppt   age height    q1    q2    q3    q4    q5    q6    q7    q8    q9\n   <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1    28    151     4     5     4     2     3     4     4     2     4\n 2     2    25    158     3     4     4     3     4     4     4     4     3\n 3     3    23     NA     1     5     3     4     2     2     4     3     4\n 4     4    25    165     1     4     4     2     5     4     4     2     2\n 5     5    21    160     1     5     3     2     4     1     3     3     2\n 6     6    20    180     4     5     2     5     1     3     4     5     3\n 7     7    27    140     2     5     4     1     4     2     4     2     3\n 8     8    28    167     2     3     5     1     3     3     2     5     1\n 9     9    22    163     3     4     5     1     5     3     5     3     3\n10    10    25    163     3     5     4     2     4     3     4     2     4\n# ℹ 66 more rows\n# ℹ 41 more variables: q10 <dbl>, q11 <dbl>, q12 <dbl>, q13 <dbl>, q14 <dbl>,\n#   q15 <dbl>, q16 <dbl>, q17 <dbl>, q18 <dbl>, q19 <dbl>, q20 <dbl>,\n#   q21 <dbl>, q22 <dbl>, q23 <dbl>, q24 <dbl>, q25 <dbl>, q26 <dbl>,\n#   q27 <dbl>, q28 <dbl>, q29 <dbl>, q30 <dbl>, q31 <dbl>, q32 <dbl>,\n#   q33 <dbl>, q34 <dbl>, q35 <dbl>, q36 <dbl>, q37 <dbl>, q38 <dbl>,\n#   q39 <dbl>, q40 <dbl>, q41 <dbl>, q42 <dbl>, q43 <dbl>, q44 <dbl>, …\n```\n:::\n:::\n\n\n:::\n::::\n\n\n# rowwise metrics\n\ncounting NAs\n\n\n# row scoring\n\nrowsums rowmeans\nNAs\n\nlink reliability\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/panelset-0.2.6/panelset.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/panelset-0.2.6/panelset.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}